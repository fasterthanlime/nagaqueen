%{
#include <stdio.h>
#include <string.h>

#define _OBRACK "{"
#define _CBRACK "}"

#define YYSTYPE char*
#define YY_STACK_SIZE 1024
%}

Module  = WS Include WS                       { printf("\n") }
        | WS Import WS                        { printf("\n") }
        | WS Stmt WS
        | WS Decl WS                          { printf("\n") }
        | WS ( !EOL . )* EOL                  { printf("error\n"); }
        
Include = INCLUDE_KW { printf("include ") }
          - IDENT  { printf("%s", yytext) }
          (
          - COMMA
          - IDENT { printf(", %s", yytext) }
          )*
          
Import  = IMPORT_KW { printf("import ") }
          - IDENT  { printf("%s", yytext) }
          (
          - COMMA
          - IDENT { printf(", %s", yytext) }
          )*

Decl    = { printf("\n"); }
          ( ClassDecl
          | CoverDecl
          | FunctionDecl
          | VariableDecl
          )

FunctionDecl =
            IDENT { printf("%s:", yytext); }
            - COLON
            
            # modifiers
            (-  ( ExternName
                | ABSTRACT_KW { printf(" abstract") }
                | STATIC_KW   { printf(" static") }
                | INLINE_KW   { printf(" inline") }
                | FINAL_KW    { printf(" final") }
                )
            )*
            
            - FUNC_KW { printf(" func") }
            
            # optional suffix
            (
            - TILDE
            - IDENT { printf(" ~%s", yytext) }
            )?
            
            # arguments are optional
            (
                - OPEN_PAREN { printf("(") }
                (WS Argument WS
                    (COMMA { printf(", ") } WS VariableDecl )*
                )?
                - CLOS_PAREN { printf(")") }
            )?
            
            # return type is optional     
            (
                - R_ARROW - { printf(" -> "); } Type
            )?
            
            # body is optional (for abstract/extern-named functions)
            (
                - OPEN_BRACK WS { printf(" %s\n", _OBRACK) }
                ({ printf("    "); } WS (Stmt) WS)*
                WS CLOS_BRACK  { printf("%s\n", _CBRACK); }
            )?
            
Argument    = ( VariableDecl
               | Type
               )
            
            
ClassDecl   =
            IDENT { printf("%s:", yytext); }
            - COLON
            
            # modifiers
            (-  ( ExternName
                | ABSTRACT_KW { printf(" abstract") }
                | FINAL_KW    { printf(" final") }
                )
            )*
            
            - CLASS_KW { printf(" class") }
            
            # subclassing
            (
            - EXTENDS_KW - IDENT { printf(" extends %s", yytext) }
            )?
            
            # body is optional (for abstract classes)
            (
                - OPEN_BRACK WS { printf(" %s\n", _OBRACK) }
                
                # classdecl contents
                (WS
                    { printf("\n") }
                    ( VariableDecl
                    | FunctionDecl
                    )
                WS)*
                
                WS CLOS_BRACK  { printf("\n%s", _CBRACK); }
            )?
            
CoverDecl   =
            IDENT { printf("%s:", yytext); }
            - COLON
            
            # modifiers
            (- ExternName)?
            
            - COVER_KW { printf(" cover") }
            
            # covering another type
            (
            - FROM_KW { printf(" from ") }
            - Type
            )?

            # body is optional for covers
            (
                - OPEN_BRACK WS { printf(" %s\n", _OBRACK) }
                
                # coverdecl contents
                (WS
                    { printf("\n") }
                    ( VariableDecl
                    | FunctionDecl
                    )
                WS)*
                
                WS CLOS_BRACK  { printf("\n%s", _CBRACK); }
            )?
            
ExternName = EXTERN_KW { printf(" extern") }
              (
              - OPEN_PAREN
              - IDENT { printf("(%s)", yytext); }
              - CLOS_PAREN
              )?

VariableDecl = 
            IDENT { printf("%s", yytext); }
            (ASS { printf(" = "); } Expr)?
            
            # multi-decls
            (
            - COMMA
            - IDENT { printf(", %s", yytext) }
            (- ASS { printf(" = "); } Expr)?
            -
            )*
            
            - COLON { printf(": "); }
            - Type
            
Type    = < (
                ( "unsigned"  { printf("unsigned ") }
                | "signed"    { printf("signed ") }
                | "long"      { printf("long ") }
                )
            - )*
            IDENT { printf("%s", yytext); } 
            (STAR { printf("*"); } 
            | "[" { printf("["); } - Expr? "]" { printf("]"); }
            )*
          > -       { $$=strdup(yytext); }

Stmt    = ( # some statements need an EOL after them...
              ( WS r:Return
              | WS e:Expr
              )
              (EOL | (&CLOS_BRACK))                 { printf("\n"); }
          )
          | # ...but block don't
          ( WS c:Conditional
          | WS f:FlowControl
          )
          
Conditional = (If | Else)

If      = IF_KW     { printf("if ("); }
          - OPEN_PAREN
          - Expr
          - CLOS_PAREN  { printf(") "); }
          - Body
          
Else    = ELSE_KW   { printf("else ("); }
          - OPEN_PAREN
          - Expr
          - CLOS_PAREN  { printf(") "); }
          - Body
          
FlowControl = (Foreach | While)
          
Foreach = FOR_KW        { printf("for ("); }
          - OPEN_PAREN
          - Expr
          - IN_KW       { printf(" in "); }
          - Expr
          - CLOS_PAREN  { printf(") "); }
          - Body
          
While = WHILE_KW    { printf("while ("); }
        - OPEN_PAREN
        - Expr
        - CLOS_PAREN  { printf(") "); }
        - Body

Body =  (
        OPEN_BRACK    { printf(" %s\n", _OBRACK) }
        (WS Stmt WS)*
        WS CLOS_BRACK   { printf("\n%s", _CBRACK) }
        ) | Stmt
          
Return  = RETURN_KW { printf("return ") } - e:Expr

Expr    = b:BinaryOperation -

#operators

BinaryOperation = Assignment

Assignment = l: LogicalOr
                ( ASS           { printf(" = ");   }    r: LogicalOr
                | ASS_ADD       { printf(" += ");  }    r: LogicalOr
                | ASS_SUB       { printf(" -= ");  }    r: LogicalOr
                | ASS_MUL       { printf(" *= ");  }    r: LogicalOr
                | ASS_DIV       { printf(" /= ");  }    r: LogicalOr
                | ASS_B_LSHIFT  { printf(" >>= "); }    r: LogicalOr
                | ASS_B_RSHIFT  { printf(" <<= "); }    r: LogicalOr
                | ASS_B_XOR     { printf(" ^= ");  }    r: LogicalOr
                | ASS_B_OR      { printf(" |= ");  }    r: LogicalOr
                | ASS_B_AND     { printf(" &= ");  }    r: LogicalOr
                | ASS_DECL      { printf(" := ");  }    r: LogicalOr
                )*

LogicalOr = l:LogicalAnd
                ( L_OR          { printf(" || "); }     r: LogicalAnd
                )*

LogicalAnd = l:BinaryOr
                ( L_AND         { printf(" && "); }     r: BinaryOr
                )*

BinaryOr = l:BinaryXor
                ( B_OR          { printf(" | "); }      r: BinaryXor
                )*

BinaryXor = l:BinaryAnd
                ( B_XOR         { printf(" ^ "); }      r: BinaryAnd
                )*

BinaryAnd = l:Equality
                ( B_AND         { printf(" & "); }      r: Equality
                )*

Equality = l:Inequality
                ( EQUALS        { printf(" == "); }     r:Inequality
                | NOT_EQUALS    { printf(" != "); }     r:Inequality
                )*

Inequality = l:Range
                ( LESSTHAN      { printf(" < ");  }     r:Range
                | MORETHAN      { printf(" > ");  }     r:Range
                | LESSTHAN_EQ   { printf(" <= "); }     r:Range
                | MORETHAN_EQ   { printf(" >= "); }     r:Range
                )*
                
Range   = l:Shift
                ( DOUBLE_DOT    { printf("..");   }     r:Shift
                )*

Shift   = l:Sum
                ( B_LSHIFT      { printf(" << "); }     r:Sum
                | B_RSHIFT      { printf(" >> "); }     r:Sum
                )*

Sum     = l:Product
                ( PLUS          { printf(" + "); }      r:Product
                | MINUS         { printf(" - "); }      r:Product
                )*

Product = ( L_NOT               { printf("!"); }
          | B_NOT               { printf("~"); }
          )*
          l:Cast
                ( STAR         { printf(" * "); }       r:Cast
                | SLASH        { printf(" / "); }       r:Cast
                )*
                
Cast = l: Access
                ( AS_KW -      { printf(" as "); }      r:Type
                )*
                
Access = Value
                ( { printf("["); } OPEN_SQUAR - Expr - CLOS_SQUAR - { printf("]"); }
                | { printf(" "); } FunctionCall -
                | { printf(" "); } VariableAccess -
                )*
                
FunctionCall = IDENT OPEN_PAREN { printf("%s(", yytext); } -
               (Expr (- COMMA { printf(", "); } WS Expr)*)?
               - CLOS_PAREN { printf(")"); }

VariableAccess = i:IDENT          { printf("%s", yytext)   }

Value   = f:FLOAT_LIT                                     { printf("%s", yytext); }
        | i:INT_LIT                                       { printf("%s", yytext); }
        | s:STRING_LIT                                    { printf("\"%s\"", yytext); }
        | c:CHAR_LIT                                      { printf("'%s'", yytext); }
        | OPEN_PAREN { printf("(") }  i:Expr CLOS_PAREN   { printf(")"); }
        | VariableDecl
        | FunctionCall
        | VariableAccess

RETURN_KW    = "return"
FUNC_KW      = "func"
CLASS_KW     = "class"
COVER_KW     = "cover"
FROM_KW      = "from"
ABSTRACT_KW  = "abstract"
FINAL_KW     = "final"
STATIC_KW    = "static"
INLINE_KW    = "inline"
EXTENDS_KW   = "extends"
EXTERN_KW    = "extern"

IMPORT_KW    = "import"
INCLUDE_KW   = "include"
IF_KW        = "if"
ELSE_KW      = "else"
FOR_KW       = "for"
WHILE_KW     = "while"
IN_KW        = "in"
AS_KW        = "as"

KW           = RETURN_KW | FUNC_KW | CLASS_KW | COVER_KW | FROM_KW
             | ABSTRACT_KW | FINAL_KW | STATIC_KW | INLINE_KW
             | EXTENDS_KW | EXTERN_KW | IMPORT_KW | INCLUDE_KW
             | IF_KW | ELSE_KW | FOR_KW | WHILE_KW | IN_KW | AS_KW

COMMA        = ','
DOT          = !DOUBLE_DOT '.'
COLON        = !ASS_DECL ':'

R_ARROW      = '->'

# Operators

ASS_DECL     = ':='  -
ASS          = '='   -
ASS_ADD      = '+='  -
ASS_SUB      = '-='  -
ASS_MUL      = '*='  -
ASS_DIV      = '/='  -
ASS_B_RSHIFT = '>>='  -
ASS_B_LSHIFT = '<<='  -
ASS_B_XOR    = '^='  -
ASS_B_OR     = '|='  -
ASS_B_AND    = '&='  -

L_OR         = '||'  -

L_AND        = '&&'  -

B_OR         = !L_OR '|'   -

B_XOR        = '^'   -

B_AND        = !L_AND '&'   -

EQUALS       = '=='  -
NOT_EQUALS   = '!='  -

LESSTHAN     = '<'   -
MORETHAN     = '>'   -
LESSTHAN_EQ  = '<='  -
MORETHAN_EQ  = '>='  -

B_LSHIFT     = '<<'  -
B_RSHIFT     = '>>'  -

DOUBLE_DOT   = '..'  -

L_NOT        = '!'   -
B_NOT        = '~'   -
PLUS         = '+'   -
MINUS        = '-'   -

STAR         = '*'   -
SLASH        = '/'   -

OPEN_PAREN   = '('   -
CLOS_PAREN   = ')'   -

OPEN_SQUAR   = '['   -
CLOS_SQUAR   = ']'   -

OPEN_BRACK   = '{'   -
CLOS_BRACK   = '}'   -

TILDE   = '~'   -
-       = [ \t]*
EOL     = '\n' | '\r\n' | '\r' | ';'
WS      = ([ \t] | Comment | EOL)*

Comment = (CommentLine | CommentMultiLine)
CommentLine = "//" (!EOL .)* EOL
CommentMultiLine = "/*" (!"*/" .)* "*/"

FLOAT_LIT    = < "-"? [0-9]+ DOT [0-9]* >                   -
INT_LIT      = < "-"? [0-9]+ >                   -
IDENT        = !(KW ![A-Za-z0-9_])  # a keyword is not a name ;)
               < [a-zA-Z_][0-9a-zA-Z_]*  >  -   { $$=strdup(yytext); }

STRING_LIT   = ["] < (!'"' ('\\\"' | '\\n' | '\\r' | '\\t' | '\\0' | .))* > ["]       -
CHAR_LIT     = ['] < (!'"' ("\\\'" | '\\n' | '\\r' | '\\t' | '\\0' | .))  > [']       -

%%

int main()
{
  GREG g;
  while (yyparse(&g));

  return 0;
}
