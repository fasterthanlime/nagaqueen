%{
#include <stdio.h>
#include <string.h>

#define _OBRACK "{"
#define _CBRACK "}"

#define YYSTYPE char*
%}

Module  = WS Stmt WS
        | WS Decl WS
        | WS ( !EOL . )* EOL                  { printf("error\n"); }

Decl    = (FunctionDecl | VariableDecl)       { printf("\n"); }

FunctionDecl =
            IDENT { printf("%s: func", yytext); }
            - COLON
            - FUNC_KW
            (- R_ARROW - { printf(" -> "); } Type)?
            - OPEN_BRACK WS { printf(" %s\n", _OBRACK) }
            ({ printf("    "); } WS Stmt WS)*
            EOL* CLOS_BRACK  { printf("%s\n", _CBRACK); }

VariableDecl = 
            IDENT { printf("%s: ", yytext); } 
            - COLON - Type  -
            
Type    = < IDENT { printf("%s", yytext); } 
            (STAR { printf("*"); } 
            | "[" { printf("["); } - Expr? "]" { printf("]"); }
            )*
          > -       { $$=strdup(yytext); }

Stmt    = WS e:Expr EOL                    { printf("\n"); }

Expr    = b:BinaryOperation -

#operators

BinaryOperation = Assignment

Assignment = l: LogicalOr
                ( ASS           { printf(" = ");   }    r: LogicalOr
                | ASS_ADD       { printf(" += ");  }    r: LogicalOr
                | ASS_SUB       { printf(" -= ");  }    r: LogicalOr
                | ASS_MUL       { printf(" *= ");  }    r: LogicalOr
                | ASS_DIV       { printf(" /= ");  }    r: LogicalOr
                | ASS_B_LSHIFT  { printf(" >>= "); }    r: LogicalOr
                | ASS_B_RSHIFT  { printf(" <<= "); }    r: LogicalOr
                | ASS_B_XOR     { printf(" ^= ");  }    r: LogicalOr
                | ASS_B_OR      { printf(" |= ");  }    r: LogicalOr
                | ASS_B_AND     { printf(" &= ");  }    r: LogicalOr
                )*

LogicalOr = l:LogicalAnd
                ( L_OR          { printf(" || "); }     r: LogicalAnd
                )*

LogicalAnd = l:BinaryOr
                ( L_AND         { printf(" && "); }     r: BinaryOr
                )*

BinaryOr = l:BinaryXor
                ( B_OR          { printf(" | "); }      r: BinaryXor
                )*

BinaryXor = l:BinaryAnd
                ( B_XOR         { printf(" ^ "); }      r: BinaryAnd
                )*

BinaryAnd = l:Equality
                ( B_AND         { printf(" & "); }      r: Equality
                )*

Equality = l:Inequality
                ( EQUALS        { printf(" == "); }     r:Inequality
                | NOT_EQUALS    { printf(" != "); }     r:Inequality
                )*

Inequality = l:Shift
                ( LESSTHAN      { printf(" < ");  }     r:Shift
                | MORETHAN      { printf(" > ");  }     r:Shift
                | LESSTHAN_EQ   { printf(" <= "); }     r:Shift
                | MORETHAN_EQ   { printf(" >= "); }     r:Shift
                )*

Shift   = l:Sum
                ( B_LSHIFT      { printf(" << "); }     r:Sum
                | B_RSHIFT      { printf(" >> "); }     r:Sum
                )*

Sum     = l:Product
                ( PLUS          { printf(" + "); }      r:Product
                | MINUS         { printf(" - "); }      r:Product
                )*

Product = l:Access
                ( STAR         { printf(" * "); }       r:Value
                | SLASH        { printf(" / "); }       r:Value
                )*
                
Access = Value
                ( { printf("["); } OPEN_SQUAR - Expr - CLOS_SQUAR { printf("]"); }
                | { printf(" "); } FunctionCall
                | { printf(" "); } VariableAccess
                )*
                
FunctionCall = IDENT OPEN_PAREN { printf("%s(", yytext); } -
               (Expr (- COMMA { printf(", "); } - Expr)*)?
               - CLOS_PAREN { printf(")"); }

VariableAccess = i:IDENT          { printf("%s", yytext)   }

Value   = i:NUMBER                                        { printf("%s", yytext); }
        | s:STRING_LIT                                    { printf("\"%s\"", yytext); }
        | OPEN_PAREN { printf("(") }  i:Expr CLOS_PAREN   { printf(")"); }
        | FunctionCall
        | VariableAccess

FUNC_KW      = "func"
CLASS_KW     = "class"
KW           = FUNC_KW | CLASS_KW

NUMBER       = < [0-9]+ >                   -
IDENT        = !KW < [a-zA-Z_][0-9a-zA-Z_]*  >  -   { $$=strdup(yytext); }

STRING_LIT   = '"' < (!'"' ('\\\"' | '\\\n' | '\\\r' | '\\\t' | .))* > '"'       -

COMMA        = ','
COLON        = ':'

R_ARROW      = '->'

# Operators

ASS          = '='   -
ASS_ADD      = '+='  -
ASS_SUB      = '-='  -
ASS_MUL      = '*='  -
ASS_DIV      = '/='  -
ASS_B_RSHIFT = '>>='  -
ASS_B_LSHIFT = '<<='  -
ASS_B_XOR    = '^='  -
ASS_B_OR     = '|='  -
ASS_B_AND    = '&='  -

L_OR         = '||'  -

L_AND        = '&&'  -

B_OR         = !L_OR '|'   -

B_XOR        = '^'   -

B_AND        = !L_AND '&'   -

EQUALS       = '=='  -
NOT_EQUALS   = '!='  -

LESSTHAN     = '<'   -
MORETHAN     = '>'   -
LESSTHAN_EQ  = '<='  -
MORETHAN_EQ  = '>='  -

B_LSHIFT     = '<<'  -
B_RSHIFT     = '>>'  -

PLUS         = '+'   -
MINUS        = '-'   -

STAR         = '*'   -
SLASH        = '/'   -

OPEN_PAREN   = '('   -
CLOS_PAREN   = ')'   -

OPEN_SQUAR   = '['   -
CLOS_SQUAR   = ']'   -

OPEN_BRACK   = '{'   -
CLOS_BRACK   = '}'   -

-       = [ \t]*
EOL     = '\n' | '\r\n' | '\r' | ';'
WS      = ([ \t] | EOL)*

%%

int main()
{
  fflush(stdout);
  while (yyparse());

  return 0;
}
