%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// workaround for peg/leg/greg's shady parsing of "{}" even in 
// character class literals
#define _OBRACK "{"
#define _CBRACK "}"

// TODO: not everyone wants to use nagaqueen with the gc, make that
// more modular
void *GC_malloc(size_t);
void *GC_calloc(size_t, size_t);
void *GC_realloc(void *, size_t);
void GC_free(void *);

#ifdef __OOC_USE_GC__

#define YY_ALLOC(N, D)      GC_malloc(N)
#define YY_CALLOC(N, S, D)  GC_malloc((N) * (S))
#define YY_REALLOC(B, N, D) GC_realloc(B, N)
#define YY_FREE             GC_free

#else

#define YY_ALLOC(N, D)      malloc(N)
#define YY_CALLOC(N, S, D)  calloc(N, S)
#define YY_REALLOC(B, N, D) realloc(B, N)
#define YY_FREE             free

#endif

#define tokenPos { core->token[0] = thunk->begin + G->offset; core->token[1] = (thunk->end - thunk->begin); }

#define YYSTYPE void*

// in old peg/leg versions, this was set to 32, but it's wayyy too small
// for a non-trivial grammar like ooc's
#define YY_STACK_SIZE 1024

//#define YY_DEBUG 1

/* Send input to yyparse from codebuf instead of stdin */
#define YY_INPUT(buf, result, max_size) {        \
    result = fread(buf, 1, max_size, core->stream);    \
    static int doneNewlineHack = 0;              \
    if(result == 0 && doneNewlineHack == 0) {    \
        doneNewlineHack = 1;                     \
        char last = buf[strlen(buf) - 1];        \
        if(last != '\n') {                       \
            (*buf) = '\n';                       \
            result = 1;                          \
        }                                        \
    }                                            \
}

///////////////////// main struct, for the sake of being re-entrant ////////////////////////

struct _NagaQueenCore {
    /* The user's data */
    void *this;
    /* Current line number */
    int yylineno;
    /* Path of the file we're parsing. */
    char* path; 
    /* The stream we're reading from. */
    FILE *stream;
    /* The begin position and length of the current token in the text */
    int token[2];
};

typedef struct _NagaQueenCore NagaQueenCore;

#define YY_XTYPE NagaQueenCore *
#define YY_XVAR core

///////////////////// callbacks def start, you may want to skip this ////////////////////////

void nq_setTokenPositionPointer(void *this, int *tokenPosPointer);

char *nq_StringClone(char *string);

void nq_onInclude(void *this, char *path, char *name);
void nq_onImport (void *this, char *path, char *name);

void nq_onCoverStart(void *this, char *name);
void nq_onCoverFromType(void *this, void *type);
void nq_onCoverExtends(void *this, void *type);
void nq_onCoverEnd(void *this);

void nq_onClassStart(void *this, char *name);
void nq_onClassAbstract(void *this);
void nq_onClassFinal(void *this);
void nq_onClassExtends(void *this, void *type);
void nq_onClassEnd(void *this);

void nq_onVarDeclStart(void *this);
void nq_onVarDeclName(void *this, char *name);
void nq_onVarDeclExtern(void *this, char *externName);
void nq_onVarDeclExpr(void *this, void *expr);
void nq_onVarDeclType(void *this, void *type);
void nq_onVarDeclStatic(void *this);
void *nq_onVarDeclEnd(void *this);
void *nq_onVarDeclAssign(void *this, void *access, bool isConst, void *expr);

void *nq_onTypeNew(void *this, char *name);     // $$=nq_onTypeNew(yytext)
void *nq_onTypePointer(void *this, void *type); // $$=nq_onTypePointer($$)
void nq_onTypeGenericArgument(void *this, void *type, char *name);
void *nq_onFuncTypeNew(void *this);

void nq_onOperatorStart(void *this, char *symbol);
void nq_onOperatorEnd(void *this);

void nq_onFunctionStart(void *this, char *name);
void nq_onFunctionExtern(void *this, char *externName);
void nq_onFunctionAbstract(void *this);
void nq_onFunctionArgsStart(void *this);
void nq_onFunctionArgsEnd(void *this);
void nq_onFunctionReturnType(void *this, void *type);
void nq_onFunctionStatic(void *this);
void nq_onFunctionInline(void *this);
void nq_onFunctionFinal(void *this);
void nq_onFunctionSuffix(void *this, char *name);
void *nq_onFunctionEnd(void *this);

void nq_onFunctionCallStart(void *this, char *yytext);
void nq_onFunctionCallArg(void *this, void *expr);
void *nq_onFunctionCallEnd(void *this);
void nq_onFunctionCallExpr(void *this, void *call, void *expr);

void *nq_onStringLiteral(void *this, char *text);
void *nq_onCharLiteral(void *this, bool value);

void nq_onStatement(void *this, void *statement);
void *nq_onReturn(void *this, void *expr);

void *nq_onVarAccess(void *this, void *expr, char *name);
void *nq_onArrayAccess(void *this, void *array, void *index);
void nq_onVarArg(void *this);
void *nq_onCast(void *this, void *expr, void *type);

void nq_onIfStart(void *this, void *condition);
void *nq_onIfEnd(void *this);
void nq_onElseStart(void *this);
void *nq_onElseEnd(void *this);

void nq_onForeachStart(void *this, void *decl, void *collec);
void *nq_onForeachEnd(void *this);

void *nq_onEquals(void *this, void *left, void *right);
void *nq_onNotEquals(void *this, void *left, void *right);
void *nq_onLessThan(void *this, void *left, void *right);
void *nq_onMoreThan(void *this, void *left, void *right);
void *nq_onCmp(void *this, void *left, void *right);
void *nq_onLessThanOrEqual(void *this, void *left, void *right);
void *nq_onMoreThanOrEqual(void *this, void *left, void *right);

void *nq_onIntLiteral(void *this, char *value);
void *nq_onFloatLiteral(void *this, char *value);
void *nq_onBoolLiteral(void *this, bool value);
void *nq_onNull(void *this);

void *nq_onTernary(void *this, void *condition, void *ifTrue, void *ifFalse);
void *nq_onAssignAnd(void *this, void *left, void *right);
void *nq_onAssignOr(void *this, void *left, void *right);
void *nq_onAssignXor(void *this, void *left, void *right);
void *nq_onAssignRightShift(void *this, void *left, void *right);
void *nq_onAssignLeftShift(void *this, void *left, void *right);
void *nq_onAssignDiv(void *this, void *left, void *right);
void *nq_onAssignMul(void *this, void *left, void *right);
void *nq_onAssignSub(void *this, void *left, void *right);
void *nq_onAssignAdd(void *this, void *left, void *right);
void *nq_onAssign(void *this, void *left, void *right);

void *nq_onAdd(void *this, void *left, void *right);
void *nq_onSub(void *this, void *left, void *right);
void *nq_onMod(void *this, void *left, void *right);
void *nq_onMul(void *this, void *left, void *right);
void *nq_onDiv(void *this, void *left, void *right);
void *nq_onRangeLiteral(void *this, void *left, void *right);
void *nq_onBinaryLeftShift(void *this, void *left, void *right);
void *nq_onBinaryRightShift(void *this, void *left, void *right);
void *nq_onLogicalOr(void *this, void *left, void *right);
void *nq_onLogicalAnd(void *this, void *left, void *right);
void *nq_onBinaryOr(void *this, void *left, void *right);
void *nq_onBinaryXor(void *this, void *left, void *right);
void *nq_onBinaryAnd(void *this, void *left, void *right);

void *nq_onLogicalNot(void *this, void *inner);
void *nq_onBinaryNot(void *this, void *inner);
void *nq_onUnaryMinus(void *this, void *inner);

void *nq_onParenthesis(void *this, void *inner);

void nq_onGenericArgument(void *this, char *name);

void *nq_onAddressOf  (void *this, void *inner);
void *nq_onDereference(void *this, void *inner);

void nq_onMatchStart(void *this);
void nq_onMatchExpr(void *this, void *value);
void *nq_onMatchEnd(void *this);
void nq_onCaseStart(void *this);
void nq_onCaseExpr(void *this, void *value);
void nq_onCaseEnd(void *this);

void nq_error(void *this, int errorID, char *defaultMessage, int index);

/////////////////////                callbacks def end               ////////////////////////

/////////////////////                 error IDs start                ////////////////////////

// NQE stands for 'NagaQueen Error"

#define NQE_EXP_STATEMENT_OR_CLOSING_BRACKET                1
#define NQE_EXP_INC_IMP_STMT_OR_DECL                        2
#define NQE_EXP_CASE_IN_MATCH                               3

/////////////////////                  error IDs end                 ////////////////////////

%}

Module  =   WS Include WS
          | WS Import WS
          | WS Stmt WS
          | WS Decl WS
          | WS ( !EOL . )* EOL   { tokenPos; nq_error(core->this, NQE_EXP_INC_IMP_STMT_OR_DECL, "Expected include, import, statement or declaration\n", core->token[0]); }
        
Include = INCLUDE_KW
          - < [A-Za-z/.]* >  { tokenPos; nq_onInclude(core->this, "", nq_StringClone(yytext)) }
          (
          - COMMA
          - < [A-Za-z/.]* > { tokenPos; nq_onInclude(core->this, "", nq_StringClone(yytext)) }
          )*
          
Import  = IMPORT_KW
          - ImportAtom
          (
          COMMA WS
          - ImportAtom
          )*
          
ImportAtom = path:ImportPath
            ((name:ImportName { tokenPos; }           { nq_onImport(core->this, (char*) path, (char*) name); })
            | (
            OPEN_SQUAR
            (name:ImportName { tokenPos; } - COMMA WS { nq_onImport(core->this, (char*) path, (char*) name); })*
            (name:ImportName { tokenPos; }            { nq_onImport(core->this, (char*) path, (char*) name); })
            CLOS_SQUAR
            ))

ImportPath = < (([A-Za-z_0-9] | ".")+ "/")* > { $$=nq_StringClone(yytext); }
ImportName = < [A-Za-z_0-9]+ >                { $$=nq_StringClone(yytext); }
            

Decl    = ( ClassDecl
          | CoverDecl
          | OperatorDecl
          | FunctionDecl
          | VariableDecl
          )

GenericArguments = 
            (
            - LESSTHAN
            - IDENT         { nq_onGenericArgument(core->this, yytext); }
            (
            - COMMA
            - IDENT         { nq_onGenericArgument(core->this, yytext); }
            )*
            MORETHAN -
            )

OperatorDecl =
            OPERATOR_KW { tokenPos; } -
            - < ( "<=>"| ">>="| "<<="| ">>" | "<<"
                | ">=" | "<=" | "!=" | "==" | ">" | "<" | "!"
                | "+=" | "-=" | "*=" | "/=" | "+" | "-" | "*" | "/" | "="
                | "[]="| "[]" | "&&" | "||" | "%" | "as"
                | "&=" | "|=" | "^=" | "&"  | "|" | "^" | "~"
                ) >
            { nq_onOperatorStart(core->this, yytext); } -
            FunctionDeclBody
            { nq_onOperatorEnd(core->this); }
            

FunctionDecl =
            IDENT { tokenPos; nq_onFunctionStart(core->this, yytext); }
            - COLON
            
            # modifiers
            (-  ( externName:ExternName  { nq_onFunctionExtern(core->this, externName); }
                | ABSTRACT_KW { nq_onFunctionAbstract(core->this); }
                | STATIC_KW   { nq_onFunctionStatic(core->this); }
                | INLINE_KW   { nq_onFunctionInline(core->this); }
                | FINAL_KW    { nq_onFunctionFinal(core->this); }
                )
            )*
            
            - FUNC_KW
            
            # optional suffix
            (
            - TILDE
            - IDENT { nq_onFunctionSuffix(core->this, yytext); }
            )?
            
            FunctionDeclBody
            
FunctionDeclBody = (
            GenericArguments?
            
            # arguments are optional
            (
                - OPEN_PAREN { nq_onFunctionArgsStart(core->this); }
                (WS Argument WS
                    (COMMA WS Argument)*
                )?
                - CLOS_PAREN { nq_onFunctionArgsEnd(core->this); }
            )?
            
            # return type is optional     
            (
                - R_ARROW - t:Type { nq_onFunctionReturnType(core->this, t); }
            )?
            
            # body is optional (for abstract/extern-named functions)
            (
                - OPEN_BRACK WS
                (WS
                (s:Stmt  { nq_onStatement(core->this, s) })
                WS)*
                WS CLOS_BRACK ~{ nq_error(core->this, NQE_EXP_STATEMENT_OR_CLOSING_BRACKET, "Expected statement or a closing bracket", G->pos + G->offset); exit(1) }
            )?
            ) { $$=nq_onFunctionEnd(core->this); }
            
Argument    = ( (DOT IDENT -)    { printf(".%s", yytext) }
              | (ASS IDENT -)    { printf("=%s", yytext) }
              | vd:VariableDecl  { tokenPos; nq_onStatement(core->this, vd); }
              | type:Type        { nq_onTypeArg(core->this, type); }
              | "..."            { tokenPos; nq_onVarArg(core->this); }
              )
            
            
ClassDecl   = (
            IDENT { tokenPos; nq_onClassStart(core->this, yytext); }
            - COLON
            
            # modifiers
            (-  ( ExternName
                | ABSTRACT_KW { nq_onClassAbstract(core->this) }
                | FINAL_KW    { nq_onClassFinal(core->this) }
                )
            )*
            
            - CLASS_KW
            
            GenericArguments?
            
            # subclassing
            (
            - EXTENDS_KW - t:Type { nq_onClassExtends(core->this, t) }
            )?
            
            # body is optional (for abstract classes)
            (
                - OPEN_BRACK WS
                
                # classdecl contents
                (WS
                    ( vd:VariableDecl { tokenPos; nq_onStatement(core->this, vd); }
                    | fd:FunctionDecl
                    )
                WS)*
                
                WS CLOS_BRACK
            )?
            ) { nq_onClassEnd(core->this) }
            
CoverDecl   = (
            IDENT { tokenPos; nq_onCoverStart(core->this, yytext) }
            - COLON
            
            # modifiers
            (- ExternName)?
            
            - COVER_KW
            
            # covering another type
            (
            - FROM_KW - t:Type { nq_onCoverFromType(core->this, t) }
            )?
            
            # extending another type
            (
            - EXTENDS_KW - t:Type { nq_onCoverExtends(core->this, t) }
            )?

            # body is optional for covers
            (
                - OPEN_BRACK WS
                
                # coverdecl contents
                (WS
                    ( vd:VariableDecl { tokenPos; nq_onStatement(core->this, vd); }
                    | fd:FunctionDecl
                    )
                WS)*
                
                WS CLOS_BRACK
            )?
            )
            { nq_onCoverEnd(core->this); }
            
ExternName = EXTERN_KW { $$="" }
              (
              - OPEN_PAREN
              - IDENT { $$=yytext } # is that correct? should it be $$=$$? what's happening?
              - CLOS_PAREN
              )?

VariableDecl = { nq_onVarDeclStart(core->this); }
            (
            IDENT { tokenPos; nq_onVarDeclName(core->this, yytext); }
            (- ASS - Expr { nq_onVarDeclExpr(core->this, $$); })?
            
            # multi-decls
            (
            - COMMA
            - IDENT { nq_onVarDeclName(core->this, yytext); }
            (- ASS - Expr { nq_onVarDeclExpr(core->this, $$); })?
            -
            )*
            
            - COLON
            (
              (- STATIC_KW { nq_onVarDeclStatic(core->this); })
            | (- externName:ExternName { nq_onVarDeclExtern(core->this, externName); })
            )*
            - Type { nq_onVarDeclType(core->this, $$); }
            (- ASS - Expr { nq_onVarDeclExpr(core->this, $$); })?
            )  { $$=nq_onVarDeclEnd(core->this); }
            
TypeBase = FuncType |
          (< (CONST_KW -)?
            (
                ( "unsigned"             - 
                | "signed"               - 
                | "long" &(- "long")     - 
                )
            - )*
            IDENT { tokenPos; }
          > { $$=nq_onTypeNew(core->this, yytext); })
            
Type    = t:TypeBase
          (- LESSTHAN - IDENT { nq_onTypeGenericArgument(core->this, t, yytext); }
          (- COMMA    - IDENT { nq_onTypeGenericArgument(core->this, t, yytext); })*
          - MORETHAN)?
          - (STAR { $$=nq_onTypePointer(core->this, $$); }
          | "[" { printf("["); } - Expr? "]" { printf("]"); }
          )*
          -
          
FuncType  = ("Func" { tokenPos; }
            (
            - OPEN_PAREN
            (- Argument)?
            (COMMA - Argument)*
            - CLOS_PAREN
            )?
            ) { $$=nq_onFuncTypeNew(core->this); }

Stmt    = (
          ( # some statements need an EOL after them...
              ( WS r:Return
              | WS v:VariableDecl
              | WS e:Expr
              )
              (EOL | (&CLOS_BRACK) | (&CommentLine))
          )
          | # ...but block don't
          ( WS c:Conditional
          | WS f:FlowControl
          | WS m:Match
          ) )
          
Conditional = (If | Else)

If      = (
          IF_KW { tokenPos; }
          - OPEN_PAREN
          - e:Expr       { nq_onIfStart(core->this, e); }
          - CLOS_PAREN
          - Body
          )              { $$=nq_onIfEnd(core->this); }
          
Else    = (
          ELSE_KW  { tokenPos; }
                         { nq_onElseStart(core->this); }
          - Body
          )              { $$=nq_onElseEnd(core->this); }

Case    = CASE_KW  { nq_onCaseStart(core->this); }
        (- v:Expr { nq_onCaseExpr(core->this, v); })?
        WS "=>"
        - (WS
          (s:Stmt  { nq_onStatement(core->this, s) })
          WS)*
          { nq_onCaseEnd(core->this); }
          
Match   = MATCH_KW { tokenPos; nq_onMatchStart(core->this); }
            (- v: Value { nq_onMatchExpr(core->this, v); })?
          - OPEN_BRACK
          (WS Case WS)*
          WS CLOS_BRACK ~{ nq_error(core->this, NQE_EXP_CASE_IN_MATCH, "Expected case in match", G->pos + G->offset); exit(1) }
          { $$=nq_onMatchEnd(core->this); }
          
FlowControl = (Foreach | While | Break | Continue)

Break    = BREAK_KW    { tokenPos; $$=nq_onBreak(core->this); }
Continue = CONTINUE_KW { tokenPos; $$=nq_onContinue(core->this); }
          
ImplicitDecl = (v:VariableDecl { $$=v })
             | (i:IDENT        { $$=nq_onVarAccess(core->this, NULL, yytext); })
          
Foreach = FOR_KW { tokenPos; }
          - OPEN_PAREN
          - decl:ImplicitDecl
          - IN_KW
          - collec:Expr
          - CLOS_PAREN { nq_onForeachStart(core->this, decl, collec); }
          - Body
          -            { $$=nq_onForeachEnd(core->this); }
          
While = WHILE_KW { tokenPos; }
        - OPEN_PAREN
        - condition:Expr
        - CLOS_PAREN { nq_onWhileStart(core->this, condition); }
        - Body
        -            { $$=nq_onWhileEnd(core->this); }

Body =  (
        OPEN_BRACK
        (WS s:Stmt { tokenPos; nq_onStatement(core->this, s) } WS)*
        WS CLOS_BRACK
        ) | s:Stmt { tokenPos; nq_onStatement(core->this, s) }
          
Return  = (RETURN_KW { tokenPos; } - e:Expr { $$=nq_onReturn(core->this, e); })
        | (RETURN_KW { tokenPos; }          { $$=nq_onReturn(core->this, NULL); })


#Expr     = (OPEN_PAREN { tokenPos; } - i:Expr - CLOS_PAREN { $$=nq_onParenthesis(core->this, i); } -)
#         | (b:BinaryOperation -)

Expr     = BinaryOperation -

#operators

BinaryOperation = Assignment

ConstKeyword = - (!CONST_KW { $$=(void*) false } | CONST_KW { $$=(void*) true })

Assignment = l: Ternary
                ( ASS            { tokenPos; }     r: Ternary              { $$=l=nq_onAssign(core->this, l, r); }
                | ASS_ADD        { tokenPos; }     r: Ternary              { $$=l=nq_onAssignAdd(core->this, l, r); }
                | ASS_SUB        { tokenPos; }     r: Ternary              { $$=l=nq_onAssignSub(core->this, l, r); }
                | ASS_MUL        { tokenPos; }     r: Ternary              { $$=l=nq_onAssignMul(core->this, l, r); }
                | ASS_DIV        { tokenPos; }     r: Ternary              { $$=l=nq_onAssignDiv(core->this, l, r); }
                | ASS_B_LSHIFT   { tokenPos; }     r: Ternary              { $$=l=nq_onAssignLeftShift(core->this, l, r); }
                | ASS_B_RSHIFT   { tokenPos; }     r: Ternary              { $$=l=nq_onAssignRightShift(core->this, l, r); }
                | ASS_B_XOR      { tokenPos; }     r: Ternary              { $$=l=nq_onAssignXor(core->this, l, r); }
                | ASS_B_OR       { tokenPos; }     r: Ternary              { $$=l=nq_onAssignOr(core->this, l, r); }
                | ASS_B_AND      { tokenPos; }     r: Ternary              { $$=l=nq_onAssignAnd(core->this, l, r); }
                | (
                  ASS_DECL       { tokenPos; }  
                  c:ConstKeyword
                  r:Expr
                  )                   { $$=l=nq_onVarDeclAssign(core->this, l, c, r); }
                )*
                
Ternary =   cond:LogicalOr
            (
          - QUEST { tokenPos; }
          - ifTrue:LogicalOr
          - COLON
          - ifFalse:LogicalOr
            { $$=nq_onTernary(core->this, cond, ifTrue, ifFalse); }
            )?

LogicalOr = l:LogicalAnd
                ( L_OR        { tokenPos; }  r: LogicalAnd          { $$=l=nq_onLogicalOr(core->this, l, r); }
                )*

LogicalAnd = l:BinaryOr
                ( L_AND       { tokenPos; }  r: BinaryOr            { $$=l=nq_onLogicalAnd(core->this, l, r); }
                )*

BinaryOr = l:BinaryXor
                ( B_OR        { tokenPos; }  r: BinaryXor           { $$=l=nq_onBinaryOr(core->this, l, r); }
                )*

BinaryXor = l:BinaryAnd
                ( B_XOR       { tokenPos; }  r: BinaryAnd           { $$=l=nq_onBinaryXor(core->this, l, r); }
                )*

BinaryAnd = l:Equality
                ( B_AND       { tokenPos; }  r: Equality            { $$=l=nq_onBinaryAnd(core->this, l, r); }
                )*

Equality = l:Inequality
                ( EQUALS      { tokenPos; }  r:Inequality           { $$=l=nq_onEquals(core->this, l, r); }
                | NOT_EQUALS  { tokenPos; }  r:Inequality           { $$=l=nq_onNotEquals(core->this, l, r); }
                )*

Inequality = l:Range
                ( LESSTHAN    { tokenPos; }  r:Range                { $$=l=nq_onLessThan(core->this, l, r); }
                | MORETHAN    { tokenPos; }  r:Range                { $$=l=nq_onMoreThan(core->this, l, r); }
                | CMP         { tokenPos; }  r:Range                { $$=l=nq_onCmp(core->this, l, r); }
                | LESSTHAN_EQ { tokenPos; }  r:Range                { $$=l=nq_onLessThanOrEqual(core->this, l, r); }
                | MORETHAN_EQ { tokenPos; }  r:Range                { $$=l=nq_onMoreThanOrEqual(core->this, l, r); }
                )*
                
Range   = l:Shift
                ( DOUBLE_DOT  { tokenPos; }  r:Shift                { $$=l=nq_onRangeLiteral(core->this, l, r); }
                )*

Shift   = l:Sum
                ( B_LSHIFT    { tokenPos; }  r:Sum                  { $$=l=nq_onBinaryLeftShift(core->this, l, r) }
                | B_RSHIFT    { tokenPos; }  r:Sum                  { $$=l=nq_onBinaryRightShift(core->this, l, r) }
                )*

Sum     = l:Product
                ( PLUS        { tokenPos; }  r:Product              { $$=l=nq_onAdd(core->this, l, r); }
                | MINUS       { tokenPos; }  r:Product              { $$=l=nq_onSub(core->this, l, r); }
                | PERCENT     { tokenPos; }  r:Product              { $$=l=nq_onMod(core->this, l, r); }
                )*

Product = (ProductLogicalNot | ProductBinaryNot | ProductCore)
          
ProductLogicalNot = L_NOT { tokenPos; } - (inner:Product) - { $$=nq_onLogicalNot(core->this, inner); }
ProductBinaryNot  = B_NOT { tokenPos; } - (inner:Product) - { $$=nq_onBinaryNot (core->this, inner); }
          
ProductCore = l:Access
                    ( STAR        { tokenPos; } r:Access                { $$=nq_onMul(core->this, l, r); }
                    | SLASH       { tokenPos; } r:Access                { $$=nq_onDiv(core->this, l, r); }
                    )*
                
Access =  (IDENT_CORE !ASS_B_AND B_AND { $$=nq_onAddressOf(core->this, nq_onVarAccess(core->this, NULL, $$)); }) # special case: blah& is always a reference. blah & blih is a binary and.
          | l:Value
                ( OPEN_SQUAR { tokenPos; } - index:Expr - CLOS_SQUAR - { $$=l=nq_onArrayAccess(core->this, l, index); }
                | call:FunctionCall -            { nq_onFunctionCallExpr(core->this, call, l); $$=l=call; }
                | !(IN_KW ![A-Za-z0-9_]) r:IDENT { tokenPos; $$=l=nq_onVarAccess(core->this, l, r); } -
                | AS_KW { tokenPos; } - r:Type   { $$=l=nq_onCast(core->this, l, r); }
                | !ASS_B_AND B_AND - ![0-9A-Za-z_]             { $$=l=nq_onAddressOf(core->this, l); }
                | AT                             { $$=l=nq_onDereference(core->this, l); }
                )*
                
FunctionCall = (
               IDENT { tokenPos; nq_onFunctionCallStart(core->this, yytext); }
               OPEN_PAREN -
               (
               e:Expr    { tokenPos; nq_onFunctionCallArg(core->this, e); }
               (-
               COMMA
               WS
               e:Expr    { tokenPos; nq_onFunctionCallArg(core->this, e); }
               )*
               )?
               - CLOS_PAREN
               ) { $$=nq_onFunctionCallEnd(core->this); }

VariableAccess = i:IDENT

Value   = (MINUS { tokenPos; } value:ValueCore { $$=nq_onUnaryMinus(core->this, value); })
        | (OPEN_PAREN { tokenPos; } - inner:Expr - CLOS_PAREN - { $$=nq_onParenthesis(core->this, inner); })
        | ValueCore

          
ValueCore =
        ( f:FLOAT_LIT                                     { tokenPos; $$=nq_onFloatLiteral(core->this, yytext); }
        | i:INT_LIT                                       { tokenPos; $$=nq_onIntLiteral(core->this, yytext); }
        | s:STRING_LIT
        | c:CHAR_LIT                                      { tokenPos; printf("'%s'", yytext); }
        | b:BOOL_LIT                                      { tokenPos; $$=nq_onBoolLiteral(core->this, $$); }
        | NULL_KW                                         { tokenPos; $$=nq_onNull(core->this); }
        | FunctionCall
        | VariableAccess                                  { tokenPos; $$=nq_onVarAccess(core->this, NULL, yytext); }
        )

BREAK_KW     = "break"
CONTINUE_KW  = "continue"
RETURN_KW    = "return"

FUNC_KW      = "func"
CLASS_KW     = "class"
COVER_KW     = "cover"
FROM_KW      = "from"
ABSTRACT_KW  = "abstract"
FINAL_KW     = "final"
STATIC_KW    = "static"
INLINE_KW    = "inline"
EXTENDS_KW   = "extends"
EXTERN_KW    = "extern"

IMPORT_KW    = "import"
INCLUDE_KW   = "include"
IF_KW        = "if"
ELSE_KW      = "else"
FOR_KW       = "for"
WHILE_KW     = "while"
MATCH_KW     = "match"
CASE_KW      = "case"
AS_KW        = "as"
IN_KW        = "in"

OPERATOR_KW  = "operator"
CONST_KW     = "const"

TRUE_KW      = "true"
FALSE_KW     = "false"

NULL_KW      = "null"

             # class in voluntarily left out
KW           = BREAK_KW | CONTINUE_KW | RETURN_KW | FUNC_KW
             | COVER_KW | FROM_KW | ABSTRACT_KW | FINAL_KW
             | STATIC_KW | INLINE_KW | EXTENDS_KW | EXTERN_KW
             | IMPORT_KW | INCLUDE_KW | IF_KW | ELSE_KW | FOR_KW
             | WHILE_KW | AS_KW | OPERATOR_KW | CONST_KW | TRUE_KW
             | FALSE_KW | NULL_KW | MATCH_KW | CASE_KW

COMMA        = ','
DOT          = !DOUBLE_DOT '.'
COLON        = !ASS_DECL ':'

R_ARROW      = '->'

# Operators

ASS_DECL     = ':='  -
ASS          = '='   -
ASS_ADD      = '+='  -
ASS_SUB      = '-='  -
ASS_MUL      = '*='  -
ASS_DIV      = '/='  -
ASS_B_RSHIFT = '>>='  -
ASS_B_LSHIFT = '<<='  -
ASS_B_XOR    = '^='  -
ASS_B_OR     = '|='  -
ASS_B_AND    = '&='  -

QUEST        = '?'   -

L_OR         = '||'  -

L_AND        = '&&'  -

B_OR         = !L_OR '|'   -

B_XOR        = '^'   -

B_AND        = !L_AND '&'   -

EQUALS       = '=='  -
NOT_EQUALS   = '!='  -

LESSTHAN     = '<'   -
MORETHAN     = '>'   -
CMP          = '<=>' -
LESSTHAN_EQ  = '<='  -
MORETHAN_EQ  = '>='  -

B_LSHIFT     = '<<'  -
B_RSHIFT     = '>>'  -

DOUBLE_DOT   = '..'  -

L_NOT        = '!'   -
B_NOT        = '~'   -
PLUS         = '+'   -
MINUS        = '-'   -

PERCENT      = '%'   -
STAR         = '*'   -
SLASH        = '/'   -

OPEN_PAREN   = '('   -
CLOS_PAREN   = ')'   -

OPEN_SQUAR   = '['   -
CLOS_SQUAR   = ']'   -

OPEN_BRACK   = '{'   -
CLOS_BRACK   = '}'   -

AT      = '@'
TILDE   = '~'   -
-       = [ \t]*
EOL     = ('\n' | '\r\n' | '\r' | ';')  { core->yylineno++; }
WS      = ([ \t] | Comment | EOL)*

Comment = (CommentLine | CommentMultiLine)
CommentLine = "//" (!EOL .)* EOL
CommentMultiLine = "/*" (!"*/" (EOL | .))* "*/"

INT_LIT      = < "-"? [0-9]+ >                   -
FLOAT_LIT    = < "-"? [0-9]+ DOT [0-9]* >        -
IDENT        = IDENT_CORE -
IDENT_CORE   = !(KW ![A-Za-z0-9_])  # a keyword is not an ident ;)
               < [a-zA-Z_][0-9a-zA-Z_]*  > { $$=yytext; }

STRING_LIT   = ["] < (!'"' ('\\\"' | '\\n' | '\\r' | '\\t' | '\\0' | .))* > ["]       -  { $$=nq_onStringLiteral(core->this, yytext); }
CHAR_LIT     = ['] < (!'"' ("\\\'" | '\\n' | '\\r' | '\\t' | '\\0' | .))  > [']       -
BOOL_LIT     = (TRUE_KW { $$=true; } | FALSE_KW { $$=false; }) - 

%%

int nq_parse(void *this, char *path) {
    
    GREG *G = YY_ALLOC(sizeof(GREG), 0);
    
    NagaQueenCore *core = YY_ALLOC(sizeof(NagaQueenCore), 0);
    core->yylineno = 0;
    core->this = this;
    core->path = path;
    core->stream = fopen(path, "r");
    nq_setTokenPositionPointer(this, core->token);
    if(!core->stream) {
        printf("Not found: %s\n", path);
        return -1;
    }
    
    G->data = core;
    
    while (yyparse(G)) {}
    fclose(core->stream);
    
    return 0;
    
}
