%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// workaround for peg/leg/greg's shady parsing of "{}" even in 
// character class literals
#define _OBRACK "{"
#define _CBRACK "}"

// TODO: not everyone wants to use nagaqueen with the gc, make that
// more modular
void *GC_malloc(size_t);
void *GC_calloc(size_t, size_t);
void *GC_realloc(void *, size_t);
void GC_free(void *);

#ifdef __OOC_USE_GC__

#define YY_ALLOC(N, D)      GC_malloc(N)
#define YY_CALLOC(N, S, D)  GC_malloc((N) * (S))
#define YY_REALLOC(B, N, D) GC_realloc(B, N)
#define YY_FREE             GC_free

#else

#define YY_ALLOC(N, D)      malloc(N)
#define YY_CALLOC(N, S, D)  calloc(N, S)
#define YY_REALLOC(B, N, D) realloc(B, N)
#define YY_FREE             free

#endif

#define tokenPos { core->token[0] = thunk->begin + G->offset; core->token[1] = (thunk->end - thunk->begin); }

#define YYSTYPE void*

// in old peg/leg versions, this was set to 32, but it's wayyy too small
// for a non-trivial grammar like ooc's
#define YY_STACK_SIZE 1024

//#define YY_DEBUG 1

///////////////////// main struct, for the sake of being re-entrant ////////////////////////

struct _NagaQueenCore {
    /* The user's data */
    void *this;
    /* Current line number */
    int yylineno;
    /* Path of the file we're parsing. */
    char* path; 
    /* The stream we're reading from. */
    FILE *stream;
    /* The begin position and length of the current token in the text */
    int token[2];
    /* type parsing buffer */
    char typeBuffer[4096];
    /* import quantity */
    int importQuantity;
};

typedef struct _NagaQueenCore NagaQueenCore;

#define YY_XTYPE NagaQueenCore *
#define YY_XVAR core

/* Send input to yyparse from codebuf instead of stdin */
#define YY_INPUT(buf, result, max_size) yyInput(buf, &result, max_size, core)

void yyInput(char *buf, int *result, int max_size, NagaQueenCore *core) {            
    (*result) = fread(buf, 1, max_size, core->stream);  
    static int doneNewlineHack = 0;                  
    if((*result) == 0 && doneNewlineHack == 0) {        
        doneNewlineHack = 1;                         
        (*buf) = '\n';                           
        (*result) = 1;                              
        return;
    }                                             
    for(int i = 0; i < (*result) - 1; i++) {            
        if(buf[i] == '\\') {                         
            if(buf[i+1] == '\r') {                   
                buf[i] = ' ';                        
                buf[i+1] = ' ';                      
                if(buf[i+2] == '\n') {               
                    buf[i+2] == ' ';                 
                    i += 2; continue;                
                }                                    
                i += 1; continue;                    
            } else if(buf[i+1] == '\n') {            
                buf[i] = ' ';                        
                buf[i+1] = ' ';                      
                i += 1; continue;                    
            }                                        
        }                                            
    }                                                
}

///////////////////// callbacks def start, you may want to skip this ////////////////////////

void nq_setTokenPositionPointer(void *this, int *tokenPosPointer);

char *nq_StringClone(char *string);

void nq_onUse(void *this, char *name);
void nq_onInclude(void *this, char *path, char *name);
void nq_onIncludeDefine(void *this, char *name, char *value);
void nq_onImport (void *this, char *path, char *name);
void nq_onImportNamespace(void *this, char *namespace, int quantity);

void *nq_onVersionName(void *this, char *name);
void *nq_onVersionNegation(void *this, void *spec);
void *nq_onVersionAnd(void *this, void *specLeft, void *specRight);
void *nq_onVersionOr(void *this, void *specLeft, void *specRight);

void nq_onVersionStart(void *this, void *spec);
void *nq_onVersionEnd(void *this);

void nq_onCoverStart(void *this, char *name);
void nq_onCoverExtern(void *this, char *externName);
void nq_onCoverFromType(void *this, void *type);
void nq_onCoverExtends(void *this, void *type);
void nq_onCoverImplements(void *this, void *type);
void nq_onCoverEnd(void *this);

void nq_onEnumStart(void *this, char *name);
void nq_onEnumElement(void *this, char *name);
void nq_onEnumElementValue(void *this, void *value);
void nq_onEnumEnd(void *this);

void nq_onClassStart(void *this, char *name);
void nq_onClassAbstract(void *this);
void nq_onClassFinal(void *this);
void nq_onClassExtends(void *this, void *type);
void nq_onClassImplements(void *this, void *type);
void nq_onClassBody(void *this);
void nq_onClassEnd(void *this);

void nq_onInterfaceStart(void *this, char *name);
void nq_onInterfaceExtends(void *this, void *type);
void nq_onInterfaceEnd(void *this);

void nq_onVarDeclStart(void *this);
void nq_onVarDeclName(void *this, char *name);
void nq_onVarDeclExtern(void *this, char *externName);
void nq_onVarDeclUnmangled(void *this, char *unmangledName);
void nq_onVarDeclExpr(void *this, void *expr);
void nq_onVarDeclType(void *this, void *type);
void nq_onVarDeclStatic(void *this);
void nq_onVarDeclConst(void *this);
void *nq_onVarDeclEnd(void *this);
void *nq_onVarDeclAssign(void *this, void *access, void *expr);

void *nq_onTypeNew(void *this, char *name);     // $$=nq_onTypeNew(yytext)
void *nq_onTypePointer(void *this, void *type);   // $$=nq_onTypePointer($$)
void *nq_onTypeReference(void *this, void *type); // $$=nq_onTypeReference($$)
void *nq_onTypeBrackets(void *this, void *type, void *inner); // $$=nq_onTypeBrackets($$, inner)
void nq_onTypeGenericArgument(void *this, void *type, void *innerType);

void *nq_onFuncTypeNew(void *this);
void nq_onFuncTypeArgument(void *this, void *funcType, void *argType);
void nq_onFuncTypeReturnType(void *this, void *funcType, void *returnType);

void nq_onOperatorStart(void *this, char *symbol);
void nq_onOperatorEnd(void *this);

void nq_onFunctionStart(void *this, char *name);
void nq_onFunctionExtern(void *this, char *externName);
void nq_onFunctionUnmangled(void *this, char *unmangledName);
void nq_onFunctionAbstract(void *this);
void nq_onFunctionThisRef(void *this);
void nq_onFunctionArgsStart(void *this);
void nq_onFunctionArgsEnd(void *this);
void nq_onFunctionReturnType(void *this, void *type);
void nq_onFunctionConst(void *this);
void nq_onFunctionStatic(void *this);
void nq_onFunctionInline(void *this);
void nq_onFunctionFinal(void *this);
void nq_onFunctionProto(void *this);
void nq_onFunctionSuffix(void *this, char *name);
void *nq_onFunctionEnd(void *this);

void nq_onTypeArg(void *this, void *type);
void nq_onVarArg(void *this);
void nq_onDotArg(void *this, char *name);
void nq_onAssArg(void *this, char *name);

void nq_onFunctionCallStart(void *this, char *yytext);
void nq_onFunctionCallSuffix(void *this, char *yytext);
void nq_onFunctionCallArg(void *this, void *expr);
void *nq_onFunctionCallEnd(void *this);
void nq_onFunctionCallExpr(void *this, void *call, void *expr);
void nq_onFunctionCallChain(void *this, void *call, void *expr);

void nq_onArrayLiteralStart(void *this);
void *nq_onArrayLiteralEnd(void *this);

void *nq_onStringLiteral(void *this, char *text);
void *nq_onCharLiteral(void *this, char *value);

void nq_onStatement(void *this, void *statement);
void *nq_onReturn(void *this, void *expr);

void *nq_onVarAccess(void *this, void *expr, char *name);
void *nq_onArrayAccess(void *this, void *array, void *index);
void *nq_onCast(void *this, void *expr, void *type);

void *nq_onBreak(void *this);
void *nq_onContinue(void *this);

void nq_onBlockStart(void *this);
void *nq_onBlockEnd(void *this);

void nq_onIfStart(void *this, void *condition);
void *nq_onIfEnd(void *this);
void nq_onElseStart(void *this);
void *nq_onElseEnd(void *this);

void nq_onForeachStart(void *this, void *decl, void *collec);
void *nq_onForeachEnd(void *this);

void nq_onWhileStart(void *this, void *condition);
void *nq_onWhileEnd(void *this);

void *nq_onEquals(void *this, void *left, void *right);
void *nq_onNotEquals(void *this, void *left, void *right);
void *nq_onLessThan(void *this, void *left, void *right);
void *nq_onMoreThan(void *this, void *left, void *right);
void *nq_onCmp(void *this, void *left, void *right);
void *nq_onLessThanOrEqual(void *this, void *left, void *right);
void *nq_onMoreThanOrEqual(void *this, void *left, void *right);

void *nq_onDecLiteral(void *this, char *value);
void *nq_onOctLiteral(void *this, char *value);
void *nq_onHexLiteral(void *this, char *value);
void *nq_onFloatLiteral(void *this, char *value);
void *nq_onBoolLiteral(void *this, bool value);
void *nq_onNull(void *this);

void *nq_onTernary(void *this, void *condition, void *ifTrue, void *ifFalse);
void *nq_onAssignAnd(void *this, void *left, void *right);
void *nq_onAssignOr(void *this, void *left, void *right);
void *nq_onAssignXor(void *this, void *left, void *right);
void *nq_onAssignRightShift(void *this, void *left, void *right);
void *nq_onAssignLeftShift(void *this, void *left, void *right);
void *nq_onAssignDiv(void *this, void *left, void *right);
void *nq_onAssignMul(void *this, void *left, void *right);
void *nq_onAssignSub(void *this, void *left, void *right);
void *nq_onAssignAdd(void *this, void *left, void *right);
void *nq_onAssign(void *this, void *left, void *right);

void *nq_onAdd(void *this, void *left, void *right);
void *nq_onSub(void *this, void *left, void *right);
void *nq_onMod(void *this, void *left, void *right);
void *nq_onMul(void *this, void *left, void *right);
void *nq_onDiv(void *this, void *left, void *right);
void *nq_onRangeLiteral(void *this, void *left, void *right);
void *nq_onBinaryLeftShift(void *this, void *left, void *right);
void *nq_onBinaryRightShift(void *this, void *left, void *right);
void *nq_onLogicalOr(void *this, void *left, void *right);
void *nq_onLogicalAnd(void *this, void *left, void *right);
void *nq_onBinaryOr(void *this, void *left, void *right);
void *nq_onBinaryXor(void *this, void *left, void *right);
void *nq_onBinaryAnd(void *this, void *left, void *right);

void *nq_onLogicalNot(void *this, void *inner);
void *nq_onBinaryNot(void *this, void *inner);
void *nq_onUnaryMinus(void *this, void *inner);

void *nq_onParenthesis(void *this, void *inner);

void nq_onGenericArgument(void *this, char *name);

void *nq_onAddressOf  (void *this, void *inner);
void *nq_onDereference(void *this, void *inner);

void nq_onMatchStart(void *this);
void nq_onMatchExpr(void *this, void *value);
void *nq_onMatchEnd(void *this);
void nq_onCaseStart(void *this);
void nq_onCaseExpr(void *this, void *value);
void nq_onCaseEnd(void *this);

void nq_error(void *this, int errorID, char *defaultMessage, int index);

/////////////////////                callbacks def end               ////////////////////////

/////////////////////                 error IDs start                ////////////////////////

// NQE stands for 'NagaQueen Error"

#define NQE_EXP_STATEMENT_OR_CLOSING_BRACKET                1
#define NQE_EXP_INC_IMP_STMT_OR_DECL                        2
#define NQE_EXP_CASE_IN_MATCH                               3
#define NQE_EXP_VAR_OR_FUNC_DECL                            4
#define NQE_EXP_RET_TYPE                                    5

/////////////////////                  error IDs end                 ////////////////////////

%}

Module  =  ModuleCore
          | WS ( !EOL . )* EOL   { tokenPos; nq_error(core->this, NQE_EXP_INC_IMP_STMT_OR_DECL, "Expected include, import, statement or declaration\n", core->token[0]); }
          
ModuleCore = (WS VERSION_KW { tokenPos; }
              - OPEN_PAREN
              - spec:VersionSpec
              - CLOS_PAREN
              - OPEN_BRACK { nq_onVersionStart(core->this, spec); }
              WS ModuleCore* WS
              - CLOS_BRACK { nq_onVersionEnd(core->this); })
          |(WS Include WS
          | WS Import WS
          | WS Use WS
          | WS Decl WS
          | WS stmt:Stmt WS { nq_onStatement(core->this, stmt); })
          
VersionSpec = ((- OPEN_PAREN - l:VersionSpec - CLOS_PAREN) | (l:VersionCore))
                ((- '&&' { tokenPos; } - r:VersionSpec { l=$$=nq_onVersionAnd(core->this, l, r); }) |
                 (- '||' { tokenPos; } - r:VersionSpec { l=$$=nq_onVersionOr (core->this, l, r); }))*
               
VersionCore = (VersionNegation | VersionName)

VersionName = - < [a-zA-Z0-9_]+ > { tokenPos; $$=nq_onVersionName(core->this, yytext); }
VersionNegation = - '!' { tokenPos; } - spec:VersionSpec { $$=nq_onVersionNegation(core->this, spec); }

Use = USE_KW
      - UseCore
      (
      - COMMA
      - UseCore
      )*
      
UseCore = < [A-Za-z/.]* > { tokenPos; nq_onUse(core->this, nq_StringClone(yytext)) }
        
Include = INCLUDE_KW
          - IncludeCore
          (
          - COMMA
          - IncludeCore
          )*
          
IncludeCore = < [A-Za-z/.]* >  { tokenPos; nq_onInclude(core->this, "", nq_StringClone(yytext)) }
          (- '|'
           - OPEN_PAREN
           - def:IDENT  { nq_onIncludeDefine(core->this, def, ""); }
           (- COMMA
            - def:IDENT { nq_onIncludeDefine(core->this, def, ""); }
           )?
           - CLOS_PAREN
          )?
          
Import  = IMPORT_KW
          - ImportAtom
          (
          COMMA WS
          - ImportAtom
          )*
          
ImportAtom = path:ImportPath
            ((name:ImportName { tokenPos; }             { nq_onImport(core->this, (char*) path, (char*) name); }
             (- INTO_KW - namespace:IDENT               { nq_onImportNamespace(core->this, (char*) namespace, 1); })?
             ) | (
            OPEN_SQUAR { core->importQuantity = 0; }
            (name:ImportName { tokenPos; } - COMMA WS   { core->importQuantity++; nq_onImport(core->this, (char*) path, (char*) name); })*
            (name:ImportName { tokenPos; }              { core->importQuantity++; nq_onImport(core->this, (char*) path, (char*) name); })
            CLOS_SQUAR
             (- INTO_KW - namespace:IDENT               { nq_onImportNamespace(core->this, (char*) namespace, core->importQuantity); })?
            ))

ImportPath = < (([A-Za-z_0-9] | ".")+ "/")* > { $$=nq_StringClone(yytext); }
ImportName = < [A-Za-z_0-9]+ >                { $$=nq_StringClone(yytext); }
            

Decl    = ( ClassDecl
          | CoverDecl
          | EnumDecl
          | InterfaceDecl
          | OperatorDecl
          | FunctionDecl
          | vd:VariableDecl { nq_onStatement(core->this, vd); }
          )

GenericArguments = 
            (
            - LESSTHAN
            - IDENT         { nq_onGenericArgument(core->this, yytext); }
            (
            - COMMA
            - IDENT         { nq_onGenericArgument(core->this, yytext); }
            )*
            MORETHAN -
            )

OperatorDecl =
            OPERATOR_KW { tokenPos; } -
            - < ( "<=>"| ">>="| "<<="| ">>" | "<<"
                | ">=" | "<=" | "!=" | "==" | ">" | "<" | "!"
                | "+=" | "-=" | "*=" | "/=" | "+" | "-" | "*" | "/" | "="
                | "[]="| "[]" | "&&" | "||" | "%" | "as"
                | "&=" | "|=" | "^=" | "&"  | "|" | "^" | "~"
                ) >
            { nq_onOperatorStart(core->this, yytext); } -
            FunctionDeclBody
            { nq_onOperatorEnd(core->this); }
            

FunctionDecl =
            IDENT { tokenPos; nq_onFunctionStart(core->this, yytext); }
            - COLON
            
            # modifiers
            (-  ( externName:ExternName  { nq_onFunctionExtern(core->this, externName); }
                | unmangledName:UnmangledName { nq_onFunctionUnmangled(core->this, unmangledName); }
                | ABSTRACT_KW { nq_onFunctionAbstract(core->this); }
                | STATIC_KW   { nq_onFunctionStatic(core->this); }
                | INLINE_KW   { nq_onFunctionInline(core->this); }
                | FINAL_KW    { nq_onFunctionFinal(core->this); }
                | PROTO_KW    { nq_onFunctionProto(core->this); }
                )
            )*
            
            FunctionDeclCore

AnonymousFunctionDecl = { nq_onFunctionStart(core->this, ""); } FunctionDeclCore
                                    
FunctionDeclCore =
            - FUNC_KW
            (AT { nq_onFunctionThisRef(core->this); })?
            
            # optional suffix
            (
            - TILDE
            - IDENT { nq_onFunctionSuffix(core->this, yytext); }
            )?
            
            FunctionDeclBody


FunctionDeclBody = (
            GenericArguments?
            
            # arguments are optional
            (
                - OPEN_PAREN { nq_onFunctionArgsStart(core->this); }
                (WS Argument WS
                    (COMMA WS Argument)*
                )?
                - CLOS_PAREN { nq_onFunctionArgsEnd(core->this); }
            )?
            
            # return type is optional     
            (
                - R_ARROW
                - t:Type ~{ nq_error(core->this, NQE_EXP_RET_TYPE, "Expected return type!\n", G->pos + G->offset); exit(1) }
                          { nq_onFunctionReturnType(core->this, t); }
            )?
            
            # body is optional (for abstract/extern-named functions)
            (
                WS OPEN_BRACK WS
                (WS
                (s:Stmt  { nq_onStatement(core->this, s) })
                WS)*
                WS CLOS_BRACK ~{ nq_error(core->this, NQE_EXP_STATEMENT_OR_CLOSING_BRACKET, "Expected statement or a closing bracket", G->pos + G->offset); exit(1) }
            )?
            ) { $$=nq_onFunctionEnd(core->this); }
            
Argument    = ( (DOT IDENT -)    { tokenPos; nq_onDotArg(core->this, yytext); }
              | (ASS IDENT -)    { tokenPos; nq_onAssArg(core->this, yytext); }
              | vd:VariableDecl  { tokenPos; nq_onStatement(core->this, vd); }
              | type:Type        { tokenPos; nq_onTypeArg(core->this, type); }
              | "..."            { tokenPos; nq_onVarArg(core->this); }
              )
            
            
ClassDecl   = (
            IDENT { tokenPos; nq_onClassStart(core->this, yytext); }
            - COLON
            
            # modifiers
            (-  ( ExternName
                | ABSTRACT_KW { nq_onClassAbstract(core->this) }
                | FINAL_KW    { nq_onClassFinal(core->this) }
                )
            )*
            
            - CLASS_KW
            
            GenericArguments?
            
            # subclassing
            (
            - EXTENDS_KW - t:Type { nq_onClassExtends(core->this, t) }
            )?
            
            # interface subclassing
            (
            - IMPLEMENTS_KW
                     - t:Type { nq_onClassImplements(core->this, t) }
            (- COMMA - t:Type { nq_onClassImplements(core->this, t) })*
            )?
            
            { nq_onClassBody(core->this); }
            
            (
                WS OPEN_BRACK WS
                
                # classdecl contents
                (WS
                    ( vd:VariableDecl { tokenPos; nq_onStatement(core->this, vd); } Terminator+
                    | fd:FunctionDecl
                    | stmt:Stmt { tokenPos; nq_onStatement(core->this, stmt); }
                    ) ~{ nq_error(core->this, NQE_EXP_VAR_OR_FUNC_DECL, "Expected variable declaration or function declaration\n", core->token[0]); }
                WS)*
                
                WS CLOS_BRACK
            )
            ) { nq_onClassEnd(core->this) }

EnumDecl    = (
            IDENT { tokenPos; nq_onEnumStart(core->this, yytext) }
            - COLON
            - ENUM_KW

            (
                WS OPEN_BRACK WS

                # Enum elements
                EnumElement ((COMMA | Terminator+) WS EnumElement)*

                WS CLOS_BRACK
            )

            ) { nq_onEnumEnd(core->this) }

EnumElement = (
                i:IDENT { nq_onEnumElement(core->this, i); }
                (ASS v:DEC_LIT { nq_onEnumElementValue(core->this, v); })?
            )
            
CoverDecl   = (
            IDENT { tokenPos; nq_onCoverStart(core->this, yytext) }
            - COLON
            
            # modifiers
            (- externName:ExternName { nq_onCoverExtern(core->this, externName); })?
            
            - COVER_KW
            
            # covering another type
            (
            - FROM_KW - t:Type { nq_onCoverFromType(core->this, t) }
            )?
            
            # extending another type
            (
            - EXTENDS_KW - t:Type { nq_onCoverExtends(core->this, t) }
            )?
            
            # interface subclassing
            (
            - IMPLEMENTS_KW
                     - t:Type { nq_onCoverImplements(core->this, t) }
            (- COMMA - t:Type { nq_onCoverImplements(core->this, t) })*
            )?

            # body is optional for covers
            (
                WS OPEN_BRACK WS
                
                # coverdecl content
                (WS
                    ( vd:VariableDecl { tokenPos; nq_onStatement(core->this, vd); } Terminator+
                    | fd:FunctionDecl
                    ) ~{ nq_error(core->this, NQE_EXP_VAR_OR_FUNC_DECL, "Expected variable declaration or function declaration\n", core->token[0]); }
                WS)*
                
                WS CLOS_BRACK
            )?
            )
            { nq_onCoverEnd(core->this); }
            
InterfaceDecl = (
            IDENT { tokenPos; nq_onInterfaceStart(core->this, yytext) }
            - COLON
            
            - INTERFACE_KW
            
            # extending another interface
            (
            - EXTENDS_KW - t:Type { nq_onInterfaceExtends(core->this, t) }
            )?
            
            # body is required for interfaces
            (
                WS OPEN_BRACK WS
                
                # interface content
                (WS
                    (fd:FunctionDecl | " ") ~{ nq_error(core->this, NQE_EXP_VAR_OR_FUNC_DECL, "Expected function declaration\n", core->token[0]); }
                WS)*
                
                WS CLOS_BRACK
            )
            )
            { nq_onInterfaceEnd(core->this); }
            
ExternName = EXTERN_KW { $$="" }
              (
              - OPEN_PAREN
              - IDENT { $$=yytext } # is that correct? should it be $$=$$? what's happening?
              - CLOS_PAREN
              )?

UnmangledName = UNMANGLED_KW { $$="" }
             (
             - OPEN_PAREN
             - IDENT { $$=yytext } # is that correct? should it be $$=$$? what's happening?
             - CLOS_PAREN
             )?           

VarDeclFromExpr = ( i:IDENT { nq_onVarDeclStart(core->this); nq_onVarDeclName(core->this, i); }
                  - ASS_DECL       { tokenPos; }
                  (
                    (- STATIC_KW { nq_onVarDeclStatic(core->this); })
                  | (- CONST_KW  { nq_onVarDeclConst (core->this); })
                  )*
                  - r:Expr { nq_onVarDeclExpr(core->this, r); }
                  - { $$=nq_onVarDeclEnd(core->this); }
                  )

ConventionalVarDecl =
            { nq_onVarDeclStart(core->this); }
            (
            IDENT { tokenPos; nq_onVarDeclName(core->this, yytext); }
            (- ASS - Expr { nq_onVarDeclExpr(core->this, $$); })?
            
            # multi-decls
            (
            - COMMA
            WS IDENT { nq_onVarDeclName(core->this, yytext); }
            (- ASS - Expr { nq_onVarDeclExpr(core->this, $$); })?
            -
            )*
            
            WS COLON WS
            (
              (- STATIC_KW { nq_onVarDeclStatic(core->this); })
            | (- CONST_KW  { nq_onVarDeclConst (core->this); })
            | (- externName:ExternName { nq_onVarDeclExtern(core->this, externName); })
            | (- unmangledName:UnmangledName { nq_onVarDeclUnmangled(core->this, unmangledName); })
            )*
            WS Type { nq_onVarDeclType(core->this, $$); }
            (- ASS - Expr { nq_onVarDeclExpr(core->this, $$); })?
            )  { $$=nq_onVarDeclEnd(core->this); }

VariableDecl = (v:VarDeclFromExpr     { $$=v })
             | (v:ConventionalVarDecl { $$=v })
            
TypeBase = FuncType |
          (< { tokenPos; core->typeBuffer[0]='\0'; } (CONST_KW -)?
            (
                ( "unsigned"                                  { strcat(core->typeBuffer, "unsigned "); } - 
                | "signed"                                    { strcat(core->typeBuffer, "signed "); } - 
                | "long" &(- ("long" | "double" | "int"))     { strcat(core->typeBuffer, "long "); } - 
                | "struct"			                          { strcat(core->typeBuffer, "struct "); } -
                )
            - )*
            IDENT { strcat(core->typeBuffer, $$); }
          > { $$=nq_onTypeNew(core->this, core->typeBuffer); })

# a GenericType is just like a Type but with non-optional generic type arguments
# it's used when we have to decide between a Type and a VariableAccess
GenericType
        = t:TypeBase
           - LESSTHAN - t2:Type { nq_onTypeGenericArgument(core->this, t, t2); }
          (- COMMA    - t2:Type { nq_onTypeGenericArgument(core->this, t, t2); })*
           - MORETHAN
           - (STAR { t=$$=nq_onTypePointer  (core->this, t); }
          |   AT   { t=$$=nq_onTypeReference(core->this, t); }
          | "[" WS { inner=NULL; } - inner:Expr? "]" { t=$$=nq_onTypeBrackets(core->this, t, inner); }
          )*
          - { $$=t; }
            
Type    = t:TypeBase
          (- LESSTHAN - genType:Type { nq_onTypeGenericArgument(core->this, t, genType); }
          (- COMMA    - genType:Type { nq_onTypeGenericArgument(core->this, t, genType); })*
          - MORETHAN)?
          - (STAR { t=$$=nq_onTypePointer  (core->this, t); }
          |  AT   { t=$$=nq_onTypeReference(core->this, t); }
          | "[" WS { inner=NULL; } - inner:Expr? "]" { t=$$=nq_onTypeBrackets(core->this, t, inner); }
          )*
          - { $$=t; }
          
FuncTypeCore = "Func" &[^A-Za-z0-9_] { tokenPos; $$=nq_onFuncTypeNew(core->this); }          
          
FuncType  = funcType:FuncTypeCore
            (- LESSTHAN - genType:Type { nq_onTypeGenericArgument(core->this, funcType, genType); }
            (- COMMA    - genType:Type { nq_onTypeGenericArgument(core->this, funcType, genType); })*
            - MORETHAN)?
            (
            - OPEN_PAREN
            (      - argType:Type { nq_onFuncTypeArgument(core->this, funcType, argType); }
            (COMMA - argType:Type { nq_onFuncTypeArgument(core->this, funcType, argType); })*
            )?
            - CLOS_PAREN
            )?
            (- R_ARROW
             - returnType:Type { nq_onFuncTypeReturnType(core->this, funcType, returnType); }
            )?
            { $$=funcType; }

Stmt     = (
                WS VERSION_KW { tokenPos; }
                - OPEN_PAREN
                - spec:VersionSpec
                - CLOS_PAREN
                - OPEN_BRACK { nq_onVersionStart(core->this, spec); }
                WS (s:Stmt { nq_onStatement(core->this, s); })* WS
                - CLOS_BRACK { $$=nq_onVersionEnd(core->this); })
         | StmtCore

StmtCore = (
              # some statements need an EOL after them...
              e:EoledStatement (- '.' { tokenPos; } WS call:FunctionCall { nq_onStatement(core->this, e); nq_onFunctionCallChain(core->this, call, e); $$=e=call; })*
              (Terminator+ | (&CLOS_BRACK) | (&CommentLine))
           )
          | # ...but block don't
          ( WS c:Conditional
          | WS b:Block
          | WS f:FlowControl (Terminator*)
          | WS m:Match
          )
          
EoledStatement =  ( WS Return
                  | WS VariableDecl
                  | WS Expr
                  )
          
Conditional = (If | Else)

Block   = (
           OPEN_BRACK { tokenPos; nq_onBlockStart(core->this); }
          (WS s:Stmt { tokenPos; nq_onStatement(core->this, s) } WS)*
           WS CLOS_BRACK { $$=nq_onBlockEnd(core->this); }
          )

If      = (
          IF_KW { tokenPos; }
          - OPEN_PAREN
          - e:Expr       { nq_onIfStart(core->this, e); }
          - CLOS_PAREN
          - Body
          )              { $$=nq_onIfEnd(core->this); }
          
Else    = (
          ELSE_KW  { tokenPos; }
                         { nq_onElseStart(core->this); }
          - Body
          )              { $$=nq_onElseEnd(core->this); }

Case    = CASE_KW  { tokenPos; nq_onCaseStart(core->this); }
        (- v:Expr { nq_onCaseExpr(core->this, v); })?
        WS DOUBLE_ARROW
         (WS
          (s:Stmt  { nq_onStatement(core->this, s) })
          WS)*
          WS
          { nq_onCaseEnd(core->this); }
          
Match   = MATCH_KW { tokenPos; nq_onMatchStart(core->this); }
            (- v: Value { nq_onMatchExpr(core->this, v); })?
          WS OPEN_BRACK
          (WS Case WS)*
          WS CLOS_BRACK ~{ nq_error(core->this, NQE_EXP_CASE_IN_MATCH, "Expected case in match", G->pos + G->offset); exit(1) }
          { $$=nq_onMatchEnd(core->this); }
          
FlowControl = (Foreach | While | Break | Continue)

Break    = BREAK_KW    { tokenPos; $$=nq_onBreak(core->this); }
Continue = CONTINUE_KW { tokenPos; $$=nq_onContinue(core->this); }
          
ImplicitDecl = (v:VariableDecl { $$=v })
             | (i:IDENT        { $$=nq_onVarAccess(core->this, NULL, yytext); })
          
Foreach = FOR_KW { tokenPos; }
          - OPEN_PAREN
          - decl:ImplicitDecl
          - IN_KW
          - collec:Expr
          - CLOS_PAREN { nq_onForeachStart(core->this, decl, collec); }
          - Body
          -            { $$=nq_onForeachEnd(core->this); }
          
While = WHILE_KW { tokenPos; }
        - OPEN_PAREN
        - condition:Expr
        - CLOS_PAREN { nq_onWhileStart(core->this, condition); }
        - Body
        -            { $$=nq_onWhileEnd(core->this); }

Body =  (
        OPEN_BRACK
        (WS s:Stmt { tokenPos; nq_onStatement(core->this, s) } WS)*
        WS CLOS_BRACK ~{ nq_error(core->this, NQE_EXP_STATEMENT_OR_CLOSING_BRACKET, "Expected statement or a closing bracket", G->pos + G->offset); exit(1) }
        ) | s:Stmt { tokenPos; nq_onStatement(core->this, s) }
          
Return  = (RETURN_KW &([^A-Za-z_]) { tokenPos; } - e:Expr { $$=nq_onReturn(core->this, e); })
        | (RETURN_KW &([^A-Za-z_]) { tokenPos; } -        { $$=nq_onReturn(core->this, NULL); })


Expr     =   VariableDecl -
           | BinaryOperation -
           | AnonymousFunctionDecl

#operators

BinaryOperation = Assignment

Assignment = l: Ternary
                ( ASS            { tokenPos; }  WS   r: Ternary              { $$=l=nq_onAssign(core->this, l, r); }
                | ASS_ADD        { tokenPos; }  WS   r: Ternary              { $$=l=nq_onAssignAdd(core->this, l, r); }
                | ASS_SUB        { tokenPos; }  WS   r: Ternary              { $$=l=nq_onAssignSub(core->this, l, r); }
                | ASS_MUL        { tokenPos; }  WS   r: Ternary              { $$=l=nq_onAssignMul(core->this, l, r); }
                | ASS_DIV        { tokenPos; }  WS   r: Ternary              { $$=l=nq_onAssignDiv(core->this, l, r); }
                | ASS_B_LSHIFT   { tokenPos; }  WS   r: Ternary              { $$=l=nq_onAssignLeftShift(core->this, l, r); }
                | ASS_B_RSHIFT   { tokenPos; }  WS   r: Ternary              { $$=l=nq_onAssignRightShift(core->this, l, r); }
                | ASS_B_XOR      { tokenPos; }  WS   r: Ternary              { $$=l=nq_onAssignXor(core->this, l, r); }
                | ASS_B_OR       { tokenPos; }  WS   r: Ternary              { $$=l=nq_onAssignOr(core->this, l, r); }
                | ASS_B_AND      { tokenPos; }  WS   r: Ternary              { $$=l=nq_onAssignAnd(core->this, l, r); }
                )*
                
Ternary =   cond:LogicalOr
            (
          - QUEST { tokenPos; }
          - ifTrue:LogicalOr
          - COLON
          - ifFalse:LogicalOr
            { $$=nq_onTernary(core->this, cond, ifTrue, ifFalse); }
            )?

LogicalOr = l:LogicalAnd
                ( L_OR        { tokenPos; } WS  r: LogicalAnd          { $$=l=nq_onLogicalOr(core->this, l, r); }
                )*

LogicalAnd = l:BinaryOr
                ( L_AND       { tokenPos; } WS  r: BinaryOr            { $$=l=nq_onLogicalAnd(core->this, l, r); }
                )*

BinaryOr = l:BinaryXor
                ( B_OR        { tokenPos; } WS  r: BinaryXor           { $$=l=nq_onBinaryOr(core->this, l, r); }
                )*

BinaryXor = l:BinaryAnd
                ( B_XOR       { tokenPos; } WS  r: BinaryAnd           { $$=l=nq_onBinaryXor(core->this, l, r); }
                )*

BinaryAnd = l:Equality
                ( B_AND       { tokenPos; } WS  r: Equality            { $$=l=nq_onBinaryAnd(core->this, l, r); }
                )*

Equality = l:Inequality
                ( EQUALS      { tokenPos; } WS  r:Inequality           { $$=l=nq_onEquals(core->this, l, r); }
                | NOT_EQUALS  { tokenPos; } WS  r:Inequality           { $$=l=nq_onNotEquals(core->this, l, r); }
                )*

Inequality = l:Range
                ( LESSTHAN    { tokenPos; } WS  r:Range                { $$=l=nq_onLessThan(core->this, l, r); }
                | MORETHAN    { tokenPos; } WS  r:Range                { $$=l=nq_onMoreThan(core->this, l, r); }
                | CMP         { tokenPos; } WS  r:Range                { $$=l=nq_onCmp(core->this, l, r); }
                | LESSTHAN_EQ { tokenPos; } WS  r:Range                { $$=l=nq_onLessThanOrEqual(core->this, l, r); }
                | MORETHAN_EQ { tokenPos; } WS  r:Range                { $$=l=nq_onMoreThanOrEqual(core->this, l, r); }
                )*
                
Range   = l:Shift
                ( DOUBLE_DOT  { tokenPos; } WS  r:Shift                { $$=l=nq_onRangeLiteral(core->this, l, r); }
                )*

Shift   = l:Sum
                ( B_LSHIFT    { tokenPos; } WS  r:Sum                  { $$=l=nq_onBinaryLeftShift(core->this, l, r) }
                | B_RSHIFT    { tokenPos; } WS  r:Sum                  { $$=l=nq_onBinaryRightShift(core->this, l, r) }
                )*

Sum     = l:Product
                ( PLUS        { tokenPos; } WS  r:Product              { $$=l=nq_onAdd(core->this, l, r); }
                | MINUS       { tokenPos; } WS  r:Product              { $$=l=nq_onSub(core->this, l, r); }
                | PERCENT     { tokenPos; } WS  r:Product              { $$=l=nq_onMod(core->this, l, r); }
                )*

Product = (ProductLogicalNot | ProductBinaryNot | ProductCore)
          
ProductLogicalNot = L_NOT { tokenPos; } - (inner:Product) - { $$=inner=nq_onLogicalNot(core->this, inner); }
ProductBinaryNot  = B_NOT { tokenPos; } - (inner:Product) - { $$=inner=nq_onBinaryNot (core->this, inner); }
          
ProductCore = l:Access
                    ( STAR        { tokenPos; }  WS r:Access              { $$=l=nq_onMul(core->this, l, r); }
                    | SLASH       { tokenPos; }  WS r:Access              { $$=l=nq_onDiv(core->this, l, r); }
                    )*
                
Access =  (IDENT_CORE !ASS_B_AND B_AND { $$=nq_onAddressOf(core->this, nq_onVarAccess(core->this, NULL, $$)); }) # special case: blah& is always a reference. blah & blih is a binary and.
          | l:Value
                ( OPEN_SQUAR { tokenPos; } - index:Expr - CLOS_SQUAR - { $$=l=nq_onArrayAccess(core->this, l, index); }
                | call:FunctionCall -            { nq_onFunctionCallExpr(core->this, call, l); $$=l=call; }
                | !(IN_KW ![A-Za-z0-9_]) r:IDENT { tokenPos; $$=l=nq_onVarAccess(core->this, l, r); } -
                | AS_KW { tokenPos; } - r:Type   { $$=l=nq_onCast(core->this, l, r); }
                | !ASS_B_AND B_AND - ![0-9A-Za-z_]             { $$=l=nq_onAddressOf(core->this, l); }
                | AT -                           { $$=l=nq_onDereference(core->this, l); }
                )*
                
FunctionCall = (
               IDENT { tokenPos; nq_onFunctionCallStart(core->this, yytext); }
               (B_NOT - IDENT { nq_onFunctionCallSuffix(core->this, yytext); })?
               OPEN_PAREN WS
               (
               e:Expr    { tokenPos; nq_onFunctionCallArg(core->this, e); }
               (WS
               COMMA
               WS
               e:Expr    { tokenPos; nq_onFunctionCallArg(core->this, e); }
               )*
               )?
               WS CLOS_PAREN
               ) { $$=nq_onFunctionCallEnd(core->this); }

VariableAccess = i:IDENT

Value   = (MINUS { tokenPos; } value:ValueCore { $$=nq_onUnaryMinus(core->this, value); })
        | (OPEN_PAREN { tokenPos; } WS inner:Expr WS CLOS_PAREN - { $$=nq_onParenthesis(core->this, inner); })
        | ValueCore

ArrayLiteral = OPEN_SQUAR { tokenPos; } WS { nq_onArrayLiteralStart(core->this); }
                            e:Expr { nq_onStatement(core->this, e); }
               (WS COMMA WS e:Expr { nq_onStatement(core->this, e); })*
               WS CLOS_SQUAR { $$=nq_onArrayLiteralEnd(core->this); }
          
ValueCore =
        ( o:OCT_LIT -                                      { tokenPos; $$=nq_onOctLiteral(core->this, yytext); }
        | h:HEX_LIT -                                      { tokenPos; $$=nq_onHexLiteral(core->this, yytext); }
        | f:FLOAT_LIT -                                    { tokenPos; $$=nq_onFloatLiteral(core->this, yytext); }
        | d:DEC_LIT -                                      { tokenPos; $$=nq_onDecLiteral(core->this, yytext); }
        | s:STRING_LIT -
        | c:CHAR_LIT -
        | b:BOOL_LIT  -                                    { tokenPos; $$=nq_onBoolLiteral(core->this, $$); }
        | m:Match                                          { $$=m; }
        | NULL_KW &[^A-Za-z_] -                            { tokenPos; $$=nq_onNull(core->this); }
        | ArrayLiteral
        | FunctionCall
        | t:GenericType                                    { $$=t; }
        | VariableAccess                                   { tokenPos; $$=nq_onVarAccess(core->this, NULL, yytext); }
        )

BREAK_KW     = "break"
CONTINUE_KW  = "continue"
RETURN_KW    = "return"

FUNC_KW      = "func"
CLASS_KW     = "class"
COVER_KW     = "cover"
ENUM_KW      = "enum"
INTERFACE_KW = "interface"
FROM_KW      = "from"
ABSTRACT_KW  = "abstract"
FINAL_KW     = "final"
STATIC_KW    = "static"
INLINE_KW    = "inline"
EXTENDS_KW   = "extends"
EXTERN_KW    = "extern"
UNMANGLED_KW = "unmangled"
IMPLEMENTS_KW= "implements"

IMPORT_KW    = "import"
INCLUDE_KW   = "include"
USE_KW       = "use"
IF_KW        = "if"
ELSE_KW      = "else"
FOR_KW       = "for"
WHILE_KW     = "while"
MATCH_KW     = "match"
CASE_KW      = "case"
AS_KW        = "as"
IN_KW        = "in"
INTO_KW      = "into"
VERSION_KW   = "version"
PROTO_KW     = "proto"

OPERATOR_KW  = "operator"
CONST_KW     = "const"

TRUE_KW      = "true"
FALSE_KW     = "false"

NULL_KW      = "null"

             # a few keywords voluntarily left out
KW           = BREAK_KW | CONTINUE_KW | RETURN_KW | FUNC_KW
             | COVER_KW | ENUM_KW | FROM_KW | ABSTRACT_KW | FINAL_KW
             | STATIC_KW | INLINE_KW | EXTENDS_KW | EXTERN_KW | UNMANGLED_KW
             | IMPORT_KW | INCLUDE_KW | IF_KW | ELSE_KW | FOR_KW
             | WHILE_KW | AS_KW | OPERATOR_KW | CONST_KW | TRUE_KW
             | FALSE_KW | NULL_KW | MATCH_KW | CASE_KW

COMMA        = ','
DOT          = !DOUBLE_DOT '.'
COLON        = !ASS_DECL ':'

R_ARROW      = '->'
DOUBLE_ARROW = '=>'

# Operators

ASS_DECL     = ':='  -
ASS          = !DOUBLE_ARROW '=' -
ASS_ADD      = '+='  -
ASS_SUB      = '-='  -
ASS_MUL      = '*='  -
ASS_DIV      = '/='  -
ASS_B_RSHIFT = '>>='  -
ASS_B_LSHIFT = '<<='  -
ASS_B_XOR    = '^='  -
ASS_B_OR     = '|='  -
ASS_B_AND    = '&='  -

QUEST        = '?'   -

L_OR         = '||'  -

L_AND        = '&&'  -

B_OR         = !L_OR '|'   -

B_XOR        = '^'   -

B_AND        = !L_AND '&'   -

EQUALS       = '=='  -
NOT_EQUALS   = '!='  -

LESSTHAN     = '<'   -
MORETHAN     = '>'   -
CMP          = '<=>' -
LESSTHAN_EQ  = '<='  -
MORETHAN_EQ  = '>='  -

B_LSHIFT     = '<<'  -
B_RSHIFT     = '>>'  -

DOUBLE_DOT   = '..'  -

L_NOT        = '!'   -
B_NOT        = '~'   -
PLUS         = '+'   -
MINUS        = '-'   -

PERCENT      = '%'   -
STAR         = '*'   -
SLASH        = '/' ![/*]   -

OPEN_PAREN   = '('   -
CLOS_PAREN   = ')'   -

OPEN_SQUAR   = '['   -
CLOS_SQUAR   = ']'   -

OPEN_BRACK   = '{'   -
CLOS_BRACK   = '}'   -

AT         = '@'
TILDE      = '~'   -
-          = [ \t]*
EOL        = ('\n' | '\r\n' | '\r')  { core->yylineno++; }
Terminator = (CommentLine
           | CommentMultiLine? (EOL | ';')
             )
WS         = ([ \t] | Comment | EOL)*

Comment = (CommentLine | CommentMultiLine)
CommentLine = "//" (!EOL .)* EOL
CommentMultiLine = "/*" (!"*/" (EOL | .))* "*/"

OCT_LIT      = < "0c" [0-8] [0-8_]* >
HEX_LIT      = < "0x" [0-9a-fA-F] [0-9a-fA-F_]* >
FLOAT_LIT    = < "-"? [0-9_]+ DOT [0-9_]* >        -
DEC_LIT      = < "-"? [0-9] [0-9_]* >                   -
IDENT        = IDENT_CORE -
IDENT_CORE   = !(KW ![A-Za-z0-9_])  # a keyword is not an ident ;)
               < [a-zA-Z_][0-9a-zA-Z_]*  > { $$=yytext; }
               
STRING_LIT   = ["] < (!["] ("\\\"" | '\\\\' | '\\a' | '\\b' | '\\t' | '\\n' | '\\v' | '\\f' | '\\r' | '\\0' | EOL | .))* > ["]  -  { tokenPos; $$=nq_onStringLiteral(core->this, yytext); }
CHAR_LIT     = ['] < (!['] ("\\\'" | '\\\\' | '\\a' | '\\b' | '\\t' | '\\n' | '\\v' | '\\f' | '\\r' | '\\0' | .)) > [']         -  { tokenPos; $$=nq_onCharLiteral(core->this, yytext); }
BOOL_LIT     = (TRUE_KW &[^A-Za-z_] { $$=(void*) true; } | FALSE_KW &[^A-Za-z_] { $$=(void*) false; }) - 

%%

int nq_parse(void *this, char *path) {
    
    GREG *G = YY_ALLOC(sizeof(GREG), 0);
    G->buflen = 0;
    
    NagaQueenCore *core = YY_ALLOC(sizeof(NagaQueenCore), 0);
    core->yylineno = 0;
    core->this = this;
    core->path = path;
    core->stream = fopen(path, "r");
    nq_setTokenPositionPointer(this, core->token);
    if(!core->stream) {
        printf("Not found: %s\n", path);
        return -1;
    }
    
    G->data = core;
    
    while (yyparse(G)) {}
    fclose(core->stream);
    
    return 0;
    
}
