%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// workaround for peg/leg/greg's shady parsing of "{}" even in 
// character class literals
#define _OBRACK "{"
#define _CBRACK "}"

// TODO: not everyone wants to use nagaqueen with the gc, make that
// more modular
void *GC_malloc(size_t);
void *GC_calloc(size_t, size_t);
void *GC_realloc(void *, size_t);
void GC_free(void *);

#ifdef __OOC_USE_GC__

#define YY_ALLOC(N, D)      GC_malloc(N)
#define YY_CALLOC(N, S, D)  GC_malloc((N) * (S))
#define YY_REALLOC(B, N, D) GC_realloc(B, N)
#define YY_FREE             GC_free

#else

#define YY_ALLOC(N, D)      malloc(N)
#define YY_CALLOC(N, S, D)  calloc(N, S)
#define YY_REALLOC(B, N, D) realloc(B, N)
#define YY_FREE             free

#endif

#define YYSTYPE void*

// in old peg/leg versions, this was set to 32, but it's wayyy too small
// for a non-trivial grammar like ooc's
#define YY_STACK_SIZE 1024

//#define YY_DEBUG 1

/* Send input to yyparse from codebuf instead of stdin */
#define YY_INPUT(buf, result, max_size) {        \
    result = fread(buf, 1, max_size, core->stream);    \
    static int doneNewlineHack = 0;              \
    if(result == 0 && doneNewlineHack == 0) {    \
        doneNewlineHack = 1;                     \
        char last = buf[strlen(buf) - 1];        \
        if(last != '\n') {                       \
            (*buf) = '\n';                       \
            result = 1;                          \
        }                                        \
    }                                            \
}

///////////////////// main struct, for the sake of being re-entrant ////////////////////////

struct _NagaQueenCore {
    /* The user's data */
    void *this;
    /* Current line number */
    int yylineno;
    /* Path of the file we're parsing. */
    char* path; 
    /* The stream we're reading from. */
    FILE *stream;
    /* A pointer to the position in the stream */
    int* posPointer;
};

typedef struct _NagaQueenCore NagaQueenCore;

#define YY_XTYPE NagaQueenCore *
#define YY_XVAR core

///////////////////// callbacks def start, you may want to skip this ////////////////////////

void nq_setPosPointer(void *this, int *posPointer);

char *nq_StringClone(char *string);

void nq_onInclude(void *this, char *path, char *name);
void nq_onImport (void *this, char *path, char *name);

void nq_onCoverStart(void *this, char *name);
void nq_onCoverFromType(void *this, void *type);
void nq_onCoverExtends(void *this, void *type);
void nq_onCoverEnd(void *this);

void nq_onClassStart(void *this, char *name);
void nq_onClassAbstract(void *this);
void nq_onClassFinal(void *this);
void nq_onClassExtends(void *this, void *type);
void nq_onClassEnd(void *this);

void nq_onVarDeclStart(void *this);
void nq_onVarDeclName(void *this, char *name);
void nq_onVarDeclExpr(void *this, void *expr);
void nq_onVarDeclType(void *this, void *type);
void nq_onVarDeclStatic(void *this);
void *nq_onVarDeclEnd(void *this);
void *nq_onVarDeclAssign(void *this, void *access, bool isConst, void *expr);

void *nq_onTypeNew(void *this, char *name);     // $$=nq_onTypeNew(yytext)
void *nq_onTypePointer(void *this, void *type); // $$=nq_onTypePointer($$)
void *nq_onFuncTypeNew(void *this);

void nq_onFunctionStart(void *this, char *name);
void nq_onFunctionExtern(void *this, char *externName);
void nq_onFunctionAbstract(void *this);
void nq_onFunctionArgsStart(void *this);
void nq_onFunctionArgsEnd(void *this);
void nq_onFunctionReturnType(void *this, void *type);
void nq_onFunctionStatic(void *this);
void nq_onFunctionInline(void *this);
void nq_onFunctionFinal(void *this);
void nq_onFunctionSuffix(void *this, char *name);
void *nq_onFunctionEnd(void *this);

void nq_onFunctionCallStart(void *this, char *yytext);
void nq_onFunctionCallArg(void *this, void *expr);
void *nq_onFunctionCallEnd(void *this);
void nq_onFunctionCallExpr(void *this, void *call, void *expr);

void *nq_onStringLiteral(void *this, char *text);
void *nq_onCharLiteral(void *this, bool value);

void nq_onStatement(void *this, void *statement);
void *nq_onReturn(void *this, void *expr);

void *nq_onVarAccess(void *this, void *expr, char *name);
void nq_onVarArg(void *this);
void *nq_onCast(void *this, void *expr, void *type);

void nq_onIfStart(void *this, void *condition);
void *nq_onIfEnd(void *this);
void nq_onElseStart(void *this);
void *nq_onElseEnd(void *this);

void *nq_onEquals(void *this, void *left, void *right);
void *nq_onNotEquals(void *this, void *left, void *right);
void *nq_onLessThan(void *this, void *left, void *right);
void *nq_onMoreThan(void *this, void *left, void *right);
void *nq_onLessThanOrEqual(void *this, void *left, void *right);
void *nq_onMoreThanOrEqual(void *this, void *left, void *right);

void *nq_onIntLiteral(void *this, char *value);
void *nq_onBoolLiteral(void *this, bool value);

void *nq_onTernary(void *this, void *condition, void *ifTrue, void *ifFalse);
void *nq_onAssignAnd(void *this, void *left, void *right);
void *nq_onAssignOr(void *this, void *left, void *right);
void *nq_onAssignXor(void *this, void *left, void *right);
void *nq_onAssignRightShift(void *this, void *left, void *right);
void *nq_onAssignLeftShift(void *this, void *left, void *right);
void *nq_onAssignDiv(void *this, void *left, void *right);
void *nq_onAssignMul(void *this, void *left, void *right);
void *nq_onAssignSub(void *this, void *left, void *right);
void *nq_onAssignAdd(void *this, void *left, void *right);
void *nq_onAssign(void *this, void *left, void *right);

void nq_onGenericArgument(void *this, char *name);

/////////////////////                callbacks def end               ////////////////////////

%}

Module  = WS Include WS
        | WS Import WS
        | WS Stmt WS
        | WS Decl WS
        | WS ( !EOL . )* EOL                  { printf("\nerror at line %d\n", core->yylineno); }
        
Include = INCLUDE_KW
          - IDENT  { nq_onInclude(core->this, "", nq_StringClone(yytext)) }
          (
          - COMMA
          - IDENT { nq_onInclude(core->this, "", nq_StringClone(yytext)) }
          )*
          
Import  = IMPORT_KW
          - ImportAtom
          (
          COMMA WS
          - ImportAtom
          )*
          
ImportAtom = path:ImportPath
            ((name:ImportName           { nq_onImport(core->this, (char*) path, (char*) name); })
            | (
            OPEN_SQUAR
            (name:ImportName - COMMA WS { nq_onImport(core->this, (char*) path, (char*) name); })*
            (name:ImportName            { nq_onImport(core->this, (char*) path, (char*) name); })
            CLOS_SQUAR
            ))

ImportPath = < (([A-Za-z_0-9] | ".")+ "/")* > { $$=nq_StringClone(yytext); }
ImportName = < [A-Za-z_0-9]+ >                { $$=nq_StringClone(yytext); }
            

Decl    = ( ClassDecl
          | CoverDecl
          | OperatorDecl
          | FunctionDecl
          | VariableDecl
          )

OperatorDecl =
            OPERATOR_KW { printf("operator "); }
            - < (PLUS | MINUS | STAR | SLASH | EQUALS | NOT_EQUALS
              | MORETHAN | MORETHAN_EQ | LESSTHAN | LESSTHAN_EQ
              | ASS_ADD | ASS_SUB | ASS_MUL | ASS_DIV | "[]=" | "[]") >
              { printf("%s ", yytext) }
            
            # arguments are optional
            (
                - OPEN_PAREN { printf("(") }
                (WS Argument WS
                    (COMMA { printf(", ") } WS VariableDecl )*
                )?
                - CLOS_PAREN { printf(")") }
            )?
            
            # return type is optional     
            (
                - R_ARROW - { printf(" -> "); } Type
            )?
            
            # body
            - OPEN_BRACK WS { printf(" %s\n", _OBRACK) }
            (WS (Stmt) WS)*
            WS CLOS_BRACK  { printf("%s\n", _CBRACK); }

FunctionDecl =(
            IDENT { nq_onFunctionStart(core->this, yytext); }
            - COLON
            
            # modifiers
            (-  ( externName:ExternName  { nq_onFunctionExtern(core->this, externName); }
                | ABSTRACT_KW { nq_onFunctionAbstract(core->this); }
                | STATIC_KW   { nq_onFunctionStatic(core->this); }
                | INLINE_KW   { nq_onFunctionInline(core->this); }
                | FINAL_KW    { nq_onFunctionFinal(core->this); }
                )
            )*
            
            - FUNC_KW
            
            # optional suffix
            (
            - TILDE
            - IDENT { nq_onFunctionSuffix(core->this, yytext); }
            )?
            
            # generic arguments
            (
            "<" -
            IDENT -         { nq_onGenericArgument(core->this, yytext); }
            (
            COMMA - IDENT - { nq_onGenericArgument(core->this, yytext); }
            )*
            ">" -
            )?
            
            # arguments are optional
            (
                - OPEN_PAREN { nq_onFunctionArgsStart(core->this); }
                (WS Argument WS
                    (COMMA WS Argument)*
                )?
                - CLOS_PAREN { nq_onFunctionArgsEnd(core->this); }
            )?
            
            # return type is optional     
            (
                - R_ARROW - t:Type { nq_onFunctionReturnType(core->this, t); }
            )?
            
            # body is optional (for abstract/extern-named functions)
            (
                - OPEN_BRACK WS
                (WS
                (s:Stmt { nq_onStatement(core->this, s) })
                WS)*
                WS CLOS_BRACK
            )?
            ) { $$=nq_onFunctionEnd(core->this); }
            
Argument    = ( (DOT IDENT -)    { printf(".%s", yytext) }
              | (ASS IDENT -)    { printf("=%s", yytext) }
              | vd:VariableDecl  { nq_onStatement(core->this, vd); }
              | Type
              | "..."            { nq_onVarArg(core->this); }
              )
            
            
ClassDecl   = (
            IDENT { nq_onClassStart(core->this, yytext); }
            - COLON
            
            # modifiers
            (-  ( ExternName
                | ABSTRACT_KW { nq_onClassAbstract(core->this) }
                | FINAL_KW    { nq_onClassFinal(core->this) }
                )
            )*
            
            - CLASS_KW
            
            # subclassing
            (
            - EXTENDS_KW - IDENT { nq_onClassExtends(core->this, yytext) }
            )?
            
            # body is optional (for abstract classes)
            (
                - OPEN_BRACK WS
                
                # classdecl contents
                (WS
                    ( vd:VariableDecl { nq_onStatement(core->this, vd); }
                    | fd:FunctionDecl
                    )
                WS)*
                
                WS CLOS_BRACK
            )?
            ) { nq_onClassEnd(core->this) }
            
CoverDecl   = (
            IDENT { nq_onCoverStart(core->this, yytext) }
            - COLON
            
            # modifiers
            (- ExternName)?
            
            - COVER_KW
            
            # covering another type
            (
            - FROM_KW
            - Type { nq_onCoverFromType(core->this, $$) }
            )?
            
            # extending another type
            (
            - EXTENDS_KW #{ printf(" extends ") }
            - IDENT      #{ printf("%s", yytext) }
            )?

            # body is optional for covers
            (
                - OPEN_BRACK WS
                
                # coverdecl contents
                (WS
                    { printf("\n") }
                    ( vd:VariableDecl { nq_onStatement(core->this, vd); }
                    | fd:FunctionDecl
                    )
                WS)*
                
                WS CLOS_BRACK
            )?
            )
            { nq_onCoverEnd(core->this); }
            
ExternName = EXTERN_KW { $$="" }
              (
              - OPEN_PAREN
              - IDENT { $$=yytext } # is that correct? should it be $$=$$? what's happening?
              - CLOS_PAREN
              )?

VariableDecl = { nq_onVarDeclStart(core->this); }
            (
            IDENT { nq_onVarDeclName(core->this, yytext); }
            (ASS Expr { nq_onVarDeclExpr(core->this, $$); })?
            
            # multi-decls
            (
            - COMMA
            - IDENT { nq_onVarDeclName(core->this, yytext); }
            (- ASS Expr { nq_onVarDeclExpr(core->this, $$); })?
            -
            )*
            
            - COLON
            (- STATIC_KW { nq_onVarDeclStatic(core->this); })?
            - Type { nq_onVarDeclType(core->this, $$); }
            )  { $$=nq_onVarDeclEnd(core->this); }
            
Type    = FuncType |
          (< (CONST_KW -)?
            (
                ( "unsigned"             - 
                | "signed"               - 
                | "long" &(- "long")     - 
                )
            - )*
            IDENT 
          > { $$=nq_onTypeNew(core->this, yytext); }
          (STAR { $$=nq_onTypePointer(core->this, $$); }
          | "[" { printf("["); } - Expr? "]" { printf("]"); }
          )*
          -
          )
          
FuncType  = ("Func"
            (
            - OPEN_PAREN
            (- Argument)?
            (COMMA - Argument)*
            - CLOS_PAREN
            )?
            ) { $$=nq_onFuncTypeNew(core->this); }

Stmt    = (
          ( # some statements need an EOL after them...
              ( WS r:Return
              | WS v:VariableDecl
              | WS e:Expr
              )
              (EOL | (&CLOS_BRACK) | (&CommentLine))
          )
          | # ...but block don't
          ( WS c:Conditional
          | WS f:FlowControl
          ) )
          
Conditional = (If | Else)

If      = (
          IF_KW
          - OPEN_PAREN
          - e:Expr       { nq_onIfStart(core->this, e); }
          - CLOS_PAREN
          - Body
          )              { $$=nq_onIfEnd(core->this); }
          
Else    = (
          ELSE_KW        { nq_onElseStart(core->this); }
          - Body
          )              { $$=nq_onElseEnd(core->this); }
          
FlowControl = (Foreach | While)
          
Foreach = FOR_KW        { printf("for ("); }
          - OPEN_PAREN
          - (VariableDecl | Expr)
          - IN_KW       { printf(" in "); }
          - Expr
          - CLOS_PAREN  { printf(") "); }
          - Body
          
While = WHILE_KW    { printf("while ("); }
        - OPEN_PAREN
        - Expr
        - CLOS_PAREN  { printf(") "); }
        - Body

Body =  (
        OPEN_BRACK
        (WS s:Stmt { nq_onStatement(core->this, s) } WS)*
        WS CLOS_BRACK
        ) | s:Stmt { nq_onStatement(core->this, s) }
          
Return  = (RETURN_KW - e:Expr { $$=nq_onReturn(core->this, e); })

Expr    = b:BinaryOperation -

#operators

BinaryOperation = Assignment

ConstKeyword = - (!CONST_KW { $$=(void*) false } | CONST_KW { $$=(void*) true })

Assignment = l: Ternary
                ( ASS                 r: Ternary              { $$=nq_onAssign(core->this, l, r); }
                | ASS_ADD             r: Ternary              { $$=nq_onAssignAdd(core->this, l, r); }
                | ASS_SUB             r: Ternary              { $$=nq_onAssignSub(core->this, l, r); }
                | ASS_MUL             r: Ternary              { $$=nq_onAssignMul(core->this, l, r); }
                | ASS_DIV             r: Ternary              { $$=nq_onAssignDiv(core->this, l, r); }
                | ASS_B_LSHIFT        r: Ternary              { $$=nq_onAssignLeftShift(core->this, l, r); }
                | ASS_B_RSHIFT        r: Ternary              { $$=nq_onAssignRightShift(core->this, l, r); }
                | ASS_B_XOR           r: Ternary              { $$=nq_onAssignXor(core->this, l, r); }
                | ASS_B_OR            r: Ternary              { $$=nq_onAssignOr(core->this, l, r); }
                | ASS_B_AND           r: Ternary              { $$=nq_onAssignAnd(core->this, l, r); }
                | (
                  ASS_DECL         
                  c:ConstKeyword
                  r:Ternary
                  )                   { $$=nq_onVarDeclAssign(core->this, l, c, r); }
                )*
                
Ternary =   cond:LogicalOr
            (
          - QUEST
          - ifTrue:LogicalOr
          - COLON
          - ifFalse:LogicalOr
            { $$=nq_onTernary(core->this, cond, ifTrue, ifFalse); }
            )?

LogicalOr = l:LogicalAnd
                ( L_OR          { printf(" || "); }     r: LogicalAnd
                )*

LogicalAnd = l:BinaryOr
                ( L_AND         { printf(" && "); }     r: BinaryOr
                )*

BinaryOr = l:BinaryXor
                ( B_OR          { printf(" | "); }      r: BinaryXor
                )*

BinaryXor = l:BinaryAnd
                ( B_XOR         { printf(" ^ "); }      r: BinaryAnd
                )*

BinaryAnd = l:Equality
                ( B_AND         { printf(" & "); }      r: Equality
                )*

Equality = l:Inequality
                ( EQUALS        r:Inequality           { $$=nq_onEquals(core->this, l, r); }
                | NOT_EQUALS    r:Inequality           { $$=nq_onNotEquals(core->this, l, r); }
                )*

Inequality = l:Range
                ( LESSTHAN      r:Range                { $$=nq_onLessThan(core->this, l, r); }
                | MORETHAN      r:Range                { $$=nq_onMoreThan(core->this, l, r); }
                | LESSTHAN_EQ   r:Range                { $$=nq_onLessThanOrEqual(core->this, l, r); }
                | MORETHAN_EQ   r:Range                { $$=nq_onMoreThanOrEqual(core->this, l, r); }
                )*
                
Range   = l:Shift
                ( DOUBLE_DOT    { printf("..");   }     r:Shift
                )*

Shift   = l:Sum
                ( B_LSHIFT      { printf(" << "); }     r:Sum
                | B_RSHIFT      { printf(" >> "); }     r:Sum
                )*

Sum     = l:Product
                ( PLUS          { printf(" + "); }      r:Product
                | MINUS         { printf(" - "); }      r:Product
                | PERCENT       { printf(" %% "); }      r:Product
                )*

Product = ( L_NOT               { printf("!"); }
          | B_NOT               { printf("~"); }
          )*
          l:Access
                ( STAR         { printf(" * "); }       r:Access
                | SLASH        { printf(" / "); }       r:Access
                )*
                
Access = l:Value
                ( { printf("["); } OPEN_SQUAR - Expr - CLOS_SQUAR - { printf("]"); }
                | call:FunctionCall - { nq_onFunctionCallExpr(core->this, call, l); }
                | !IN_KW r:IDENT { $$=nq_onVarAccess(core->this, l, r); } -
                | AS_KW - r:Type  { $$=nq_onCast(core->this, l, r); }
                )*
                
FunctionCall = (
               IDENT { nq_onFunctionCallStart(core->this, yytext); }
               OPEN_PAREN -
               (
               e:Expr    { nq_onFunctionCallArg(core->this, e); }
               (-
               COMMA
               WS
               e:Expr    { nq_onFunctionCallArg(core->this, e); }
               )*
               )?
               - CLOS_PAREN
               ) { $$=nq_onFunctionCallEnd(core->this); }

VariableAccess = i:IDENT

Value   = ( PLUS    { printf("+"); }
          | MINUS   { printf("-"); }
          )?
        ( f:FLOAT_LIT                                     { printf("%s", yytext); }
        | i:INT_LIT                                       { $$=nq_onIntLiteral(core->this, yytext); }
        | s:STRING_LIT
        | c:CHAR_LIT                                      { printf("'%s'", yytext); }
        | b:BOOL_LIT                                      { $$=nq_onBoolLiteral(core->this, $$); }
        | OPEN_PAREN { printf("(") }  i:Expr CLOS_PAREN   { printf(")"); }
        | FunctionCall
        | VariableAccess                                  { $$=nq_onVarAccess(core->this, NULL, yytext); }
        )

RETURN_KW    = "return"
FUNC_KW      = "func"
CLASS_KW     = "class"
COVER_KW     = "cover"
FROM_KW      = "from"
ABSTRACT_KW  = "abstract"
FINAL_KW     = "final"
STATIC_KW    = "static"
INLINE_KW    = "inline"
EXTENDS_KW   = "extends"
EXTERN_KW    = "extern"

IMPORT_KW    = "import"
INCLUDE_KW   = "include"
IF_KW        = "if"
ELSE_KW      = "else"
FOR_KW       = "for"
WHILE_KW     = "while"
AS_KW        = "as"
IN_KW        = "in"

OPERATOR_KW  = "operator"
CONST_KW     = "const"

TRUE_KW      = "true"
FALSE_KW     = "false"

            # 'class', 'in' voluntarily left out
KW           = RETURN_KW | FUNC_KW | COVER_KW | FROM_KW
             | ABSTRACT_KW | FINAL_KW | STATIC_KW | INLINE_KW
             | EXTENDS_KW | EXTERN_KW | IMPORT_KW | INCLUDE_KW
             | IF_KW | ELSE_KW | FOR_KW | WHILE_KW | AS_KW
             | OPERATOR_KW | CONST_KW | TRUE_KW | FALSE_KW

COMMA        = ','
DOT          = !DOUBLE_DOT '.'
COLON        = !ASS_DECL ':'

R_ARROW      = '->'

# Operators

ASS_DECL     = ':='  -
ASS          = '='   -
ASS_ADD      = '+='  -
ASS_SUB      = '-='  -
ASS_MUL      = '*='  -
ASS_DIV      = '/='  -
ASS_B_RSHIFT = '>>='  -
ASS_B_LSHIFT = '<<='  -
ASS_B_XOR    = '^='  -
ASS_B_OR     = '|='  -
ASS_B_AND    = '&='  -

QUEST        = '?'   -

L_OR         = '||'  -

L_AND        = '&&'  -

B_OR         = !L_OR '|'   -

B_XOR        = '^'   -

B_AND        = !L_AND '&'   -

EQUALS       = '=='  -
NOT_EQUALS   = '!='  -

LESSTHAN     = '<'   -
MORETHAN     = '>'   -
LESSTHAN_EQ  = '<='  -
MORETHAN_EQ  = '>='  -

B_LSHIFT     = '<<'  -
B_RSHIFT     = '>>'  -

DOUBLE_DOT   = '..'  -

L_NOT        = '!'   -
B_NOT        = '~'   -
PLUS         = '+'   -
MINUS        = '-'   -

PERCENT      = '%'   -
STAR         = '*'   -
SLASH        = '/'   -

OPEN_PAREN   = '('   -
CLOS_PAREN   = ')'   -

OPEN_SQUAR   = '['   -
CLOS_SQUAR   = ']'   -

OPEN_BRACK   = '{'   -
CLOS_BRACK   = '}'   -

TILDE   = '~'   -
-       = [ \t]*
EOL     = ('\n' | '\r\n' | '\r' | ';')  { core->yylineno++; }
WS      = ([ \t] | Comment | EOL)*

Comment = (CommentLine | CommentMultiLine)
CommentLine = "//" (!EOL .)* EOL
CommentMultiLine = "/*" (!"*/" (EOL | .))* "*/"

INT_LIT      = < "-"? [0-9]+ >                   -
FLOAT_LIT    = < "-"? [0-9]+ DOT [0-9]* >        -
IDENT        = !(KW ![A-Za-z0-9_])  # a keyword is not an ident ;)
               < [a-zA-Z_][0-9a-zA-Z_]*  >  -   { $$=yytext; }

STRING_LIT   = ["] < (!'"' ('\\\"' | '\\n' | '\\r' | '\\t' | '\\0' | .))* > ["]       -  { $$=nq_onStringLiteral(core->this, yytext); }
CHAR_LIT     = ['] < (!'"' ("\\\'" | '\\n' | '\\r' | '\\t' | '\\0' | .))  > [']       -
BOOL_LIT     = (TRUE_KW { $$=true; } | FALSE_KW { $$=false; }) - 

%%

int nq_parse(void *this, char *path) {
    
    GREG *G = YY_ALLOC(sizeof(GREG), 0);
    
    NagaQueenCore *core = YY_ALLOC(sizeof(NagaQueenCore), 0);
    core->yylineno = 0;
    core->this = this;
    core->path = path;
    core->stream = fopen(path, "r");
    nq_setPosPointer(this, &(G->begin));
    if(!core->stream) {
        printf("Not found: %s\n", path);
        return -1;
    }
    
    G->data = core;
    
    while (yyparse(G)) {}
    fclose(core->stream);
    
    return 0;
    
}
